{"count": 3439, "next": "http://pyvideo.org/api/v2/video/?page=165&format=json", "previous": "http://pyvideo.org/api/v2/video/?page=163&format=json", "results": [{"category": "PyCon US 2011", "language": "English", "slug": "pycon-2011--supercomputer-and-cluster-application", "speakers": ["Daniel W. Barnette"], "tags": ["pycon", "pycon2011", "pylot", "sandianationallaboratories", "supercomputer"], "related_urls": [], "id": 450, "state": 1, "title": "Supercomputer and Cluster Application Performance Analysis using Python", "summary": "", "description": "PyCon 2011: Supercomputer and Cluster Application Performance Analysis using\nPython\n\nPresented by Daniel W. Barnette, PhD\n\nSandia National Labs analyzes high-performance computing environments to\noptimize application performance, analyze system architectures, and provide\ndesign guidance for future systems. We discuss 1) generating performance data\nacross multiple systems using mini-applications, and 2) using our open source\nPython tools Pylot/Co-Pylot to store and analyze data using a MySQL database\nserver.\n\nAbstract\n\nSandia National Laboratories analyzes large-scale, state-of-the-art high\nperformance computing environments for the Department of Energy (DOE),\nDepartment of Defense (DoD), and other government agencies. Execution\nefficiency is vital when dealing with datasets that require billions of\nelements or when running simulations that take millions of core-hours to\ncomplete.\n\nOne approach to investigating execution efficiency is to instrument our large-\nscale applications and platforms to generate timings and other performance\ndata. Although effective in mature computing environments, working directly\nwith large-scale applications is cumbersome, time consuming, and even\nimpossible in the early stages of computer system analysis and design.\nFurthermore, the software and data sets of these applications may be\nrestricted, limiting our abilities to collaborate.\n\nIn order to enhance our analysis capabilities far upstream from when large-\nscale applications can be used and when working with external collaborators,\nwe have developed a collection of mini-applications that capture the essence\nof our much larger scientific codes, are readily applicable to both large and\nsmall systems, and whose run-time information can accurately reveal problems\nassociated with execution efficiency.\n\nGenerating the data is only half the problem, though. We need the ability to\ncapture platform-relevant mini-app performance data at the convenience of the\ntesters when and where they generate the data. We also need the ability to\nsearch through, filter, and visualize the resulting performance measurement\ndatasets in detail to identify and understand trends and patterns.\n\nSandia National Laboratories has developed a performance analysis suite\nprimarily consisting of two tools written in Python, Pylot and Co-Pylot. Co-\nPylot is a relatively simple interface that enables easy batch transfer of\nperformance data to a remote MySQL database server for persistent storage.\n\nOnce stored, the performance data is extracted, organized, filtered, and\nanalyzed using Pylot, a more functionally complex interface. Pylot is used to\npresent user-selected MySQL database fields in a variety of views including\nstatistical data, bar and pie charts, Cartesian or log-log or semi-log plots,\nreference curves for comparisons, and Kiviat diagrams (also called radar\ncharts) for multivariate datasets.\n\nA built-in storage buffer provides the ability to store, compare, and analyze\ndata from multiple databases. This capability is critical for studying\nperformance variations of a code running on a particular architecture,\ncomparing application performance across architectures, or comparing multiple\napplications on one or more architectures. Values in up to four database\nfields at a time can be mathematically combined to generate a new temporary\nfield to provide complete generality while accessing a database. Further,\nPylot provides the ability to easily move MySQL databases and tables between\ncomputers, including the analyst\u2019s laptop. This coherency of databases across\nmultiple analysis platforms can be used, for example, to avoid network latency\nissues associated with accessing remote servers. It also serves as a\ndistributed backup system.\n\nAn outline of this presentation follows:\n\n  1. Applications at Sandia National Laboratories (6 mins) \n    * Simulation size and runtime of typical large Sandia applications \n    * Difficulties of using large-scale applications in early computer system design and analysis \n    * Mantevo mini-apps \u2013 small, self-contained programs that embody essential performance characteristics of key applications. \n  2. Gathering data (4 mins) \n    * What information Mantevo mini-apps provide \n    * Co-Pylot \u2013 getting your data into a remote database \n  3. Supercomputer and Cluster application analysis (10 mins) \n    * Pylot \u2013 demo of accessing and graphing MySQL data as a method for analyzing performance \n    * Diagnosing performance issues \n    * Comparing different systems and different runs \n  4. Future Extensions of Pylot (5 mins) \n    * Capturing compile-time and execution info \n    * Efforts to move parts of Pylot to the web \n\n", "quality_notes": "", "copyright_text": "Creative Commons Attribution-NonCommercial-ShareAlike 3.0", "embed": "", "thumbnail_url": "http://a.images.blip.tv/Pycon-PyCon2011SupercomputerAndClusterApplicationPerformanceAna648.png", "duration": null, "video_ogv_length": 144836736, "video_ogv_url": null, "video_ogv_download_only": false, "video_mp4_length": null, "video_mp4_url": "http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/450_supercomputer-and-cluster-application-performance-analysis-using-python.mp4", "video_mp4_download_only": false, "video_webm_length": null, "video_webm_url": "", "video_webm_download_only": false, "video_flv_length": null, "video_flv_url": "", "video_flv_download_only": false, "source_url": "", "whiteboard": "", "recorded": "2011-03-11", "added": "2012-02-23T04:20:00", "updated": "2014-04-08T20:28:28.038"}, {"category": "PyCon US 2011", "language": "English", "slug": "pycon-2011--supporting-all-versions-of-python-all", "speakers": ["Kumar McMillan"], "tags": ["ci", "hudson", "pycon", "pycon2011", "testing", "tox"], "related_urls": [], "id": 435, "state": 1, "title": "Supporting All Versions of Python All The Time With Tox", "summary": "", "description": "Supporting All Versions of Python All The Time With Tox\n\nPresented by Kumar McMillan\n\nThis talk explains the modern techniques that every module maintainer needs to\nknow in order to support all major versions of Python. You probably already\nhave a massive test suite using a tool like nosetests, py.test, unittest, or a\ncustom runner. Using the tox command line tool, you'll see how to run your\ntests in Python 2.x, 3.x, Jython, and whatever else in parallel.\n\nAbstract\n\ntox is a new tool that lets you set up isolated virtual environments to test\nyour module's deployment and compatibility with all major versions of Python.\nIt's easy to install and is flexible enough that it probably already supports\nyour existing test suite. With one simple command you can execute your test\nsuite in each version of Python, you can build its documentation with Sphinx,\nand get a nice printout of the results. It has also been designed from the\nground up to integrate into continuous integration (CI) tools like Hudson.\n\nUsing practical examples, this talk will show you how to toxify your existing\ntest suite and trick it out with the tox.ini config file. You'll also see how\nto leverage Hudson's matrix build so that each code checkin will run tests in\nall versions of Python and report detailed failures.\n\nYour app supports Python 3, right? No? Tox is the best way to develop in\nparallel with 2.x and 3.x. We'll go over how to set up tox for that.\n\n", "quality_notes": "", "copyright_text": "Creative Commons Attribution-NonCommercial-ShareAlike 3.0", "embed": "", "thumbnail_url": "http://a.images.blip.tv/Pycon-PyCon2011SupportingAllVersionsOfPythonAllTheTimeWithT333.png", "duration": null, "video_ogv_length": 112153712, "video_ogv_url": null, "video_ogv_download_only": false, "video_mp4_length": null, "video_mp4_url": "http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/435_supporting-all-versions-of-python-all-the-time-with-tox.mp4", "video_mp4_download_only": false, "video_webm_length": null, "video_webm_url": null, "video_webm_download_only": false, "video_flv_length": null, "video_flv_url": null, "video_flv_download_only": false, "source_url": "", "whiteboard": "", "recorded": "2011-03-11", "added": "2012-02-23T04:20:00", "updated": "2014-04-08T20:28:28.040"}, {"category": "PyCon US 2011", "language": "English", "slug": "pycon-2011--swarming-the-web--evolving-the-perfec", "speakers": ["Kurt Grandis"], "tags": ["lamp", "pycon", "pycon2011", "scipy", "tuning", "webapps"], "related_urls": [], "id": 405, "state": 1, "title": "Swarming the Web: Evolving the Perfect Config File", "summary": "", "description": "Swarming the Web: Evolving the Perfect Config File\n\nPresented by Kurt Grandis\n\nDeployed web applications are typically run on top of stacks of highly\nconfigurable middleware. The number of tunable parameters and their impact are\nrarely fully explored. Using SciPy and a set of common Python-based web tools\nthis session will present a new method of automatically tuning a typical LAMP\nstack for optimal performance.\n\nAbstract\n\nDeployed web applications typically run on top of stacks of configurable\ntechnology (e.g. web servers, interface modules, software load balancers,\ndatabases). Each of these components often has dozens of tuneable parameters.\nHow many times are those values typically tweaked before a final set of tuned\nparameters are settled on? What criteria are typically used to determine the\noptimal set?\n\nThis session presents a new method of automatically tuning a common LAMP stack\nfor optimal performance. We explore a solution using some common Python-based\nautomated deployment and load testing tools and dive into scientific computing\nwith SciPy.\n\n", "quality_notes": "", "copyright_text": "Creative Commons Attribution-NonCommercial-ShareAlike 3.0", "embed": "", "thumbnail_url": "http://a.images.blip.tv/Pycon-PyCon2011SwarmingTheWebEvolvingThePerfectConfigFile838.png", "duration": null, "video_ogv_length": 138952836, "video_ogv_url": null, "video_ogv_download_only": false, "video_mp4_length": null, "video_mp4_url": "http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/405_swarming-the-web-evolving-the-perfect-config-file.mp4", "video_mp4_download_only": false, "video_webm_length": null, "video_webm_url": null, "video_webm_download_only": false, "video_flv_length": null, "video_flv_url": null, "video_flv_download_only": false, "source_url": "", "whiteboard": "", "recorded": "2011-03-11", "added": "2012-02-23T04:20:00", "updated": "2014-04-08T20:28:28.041"}, {"category": "PyCon US 2011", "language": "English", "slug": "pycon-2011--ten-years-of-twisted", "speakers": [], "tags": ["pycon", "pycon2011", "twisted"], "related_urls": [], "id": 410, "state": 1, "title": "Ten Years of Twisted", "summary": "", "description": "Ten Years of Twisted\n\nGlyph Lefkowitz\n\nThe Twisted event-driven networking engine is well-known in the Python\ncommunity. However, only a few of its features are widely understood. This\ntalk will be a brief conceptual introduction to Twisted, followed by a survey\nof its features, their status, and how development has been proceeding over\nthe years, with a special focus on the last two years of sponsored\ndevelopment.\n\nAbstract\n\nThis talk will begin with a brief introduction to Twisted architectural\nconcepts; a description of the event loop, connections, and timers. It will\nthen segue into the many different features that Twisted offers, including\ncommand-line tools for running an out-of-the-box zero-configuration HTTP\nserver, DNS server, IRC server, and SMTP server. This will also present the\nrelative maturity and stability of each of these areas of the code, with a\nspecial emphasis on what level of expertise a developer should have before\nattempting to use them. Finally, I will describe some of the features that\nhave been added to Twisted along the way, including some new and exciting\ndevelopments that have been happening recently.\n\n", "quality_notes": "", "copyright_text": "Creative Commons Attribution-NonCommercial-ShareAlike 3.0", "embed": "", "thumbnail_url": "http://a.images.blip.tv/Pycon-PyCon2011TenYearsOfTwisted381.png", "duration": null, "video_ogv_length": 131824079, "video_ogv_url": null, "video_ogv_download_only": false, "video_mp4_length": null, "video_mp4_url": "http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/410_ten-years-of-twisted.mp4", "video_mp4_download_only": false, "video_webm_length": null, "video_webm_url": null, "video_webm_download_only": false, "video_flv_length": null, "video_flv_url": null, "video_flv_download_only": false, "source_url": "", "whiteboard": "", "recorded": "2011-03-11", "added": "2012-02-23T04:20:00", "updated": "2014-04-08T20:28:28.043"}, {"category": "PyCon US 2011", "language": "English", "slug": "pycon-2011--testing-the-mobile--and-desktop--web-", "speakers": ["Jason Huggins"], "tags": ["browsers", "embedded", "html5", "pycon", "pycon2011", "selenium", "webdriver"], "related_urls": [], "id": 373, "state": 1, "title": "Testing the Mobile (and Desktop) Web with Selenium 2.0 - Better, Faster, and more Pythonicly", "summary": "", "description": "Testing the Mobile (and Desktop) Web with Selenium 2.0 - Better, Faster, and\nmore Pythonicly\n\nPresented by Jason Huggins\n\nSelenium is a popular web application testing tool for acceptance testing\ndynamic web applications. Selenium 2.0 has a different architecture that makes\nit leaner, meaner, and more pythonic -- for testing desktop *and* mobile web\n(iPhone/Android) apps. This talk will go into detail on how Selenium 2 works.\nIf you like testing and Python, you'll enjoy what's cooking in Selenium 2.\n\nAbstract\n\nSelenium was originally created by Jason Huggins and his team at ThoughtWorks\nin 2004 as a tool for cross-browser acceptance testing of dynamic web apps --\napps that use JavaScript heavily on the client. Over the years, the Selenium\ntool family has expanded to include a Firefox record and playback tool\n(Selenium IDE), a Remote Control server that allows API access from any major\nprogramming language, and a Grid server that allows tests to run in parallel\nacross many machines.\n\nDespite it's widespread industry adoption, the Selenium project is far from\ndone. Selenium's goal is to drive any browser the same way an end user would\n(e.g. opening pages, clicking buttons, entering text, etc.) with any\nprogramming language on any OS platform. It's an ambitious goal, and with a\nsteady stream of new browsers (Chrome), new platforms (Android, iPhone), and\nnew HTML5 technologies (video, canvas, offline storage) to support, just\nkeeping up is an arduous task.\n\nAstute observers will note, though, the bulk of Selenium's automation engine\nis implemented in JavaScript, which is confined by the browser's security\nsandbox in which it executes JavaScript code. That security sandbox ultimately\nis at odds with Selenium's goal to drive the browser just as a user would. A\nuser has no problem interacting with security alerts for untrusted\ncertificates, or file upload dialog boxes, but Selenium can't deal with these\nkinds of things easily without extra effort.\n\nEnter WebDriver. There's a lot in common between the Selenium and WebDriver\nprojects. They're both tools for automated testing of web applications, and\nboth aspire to offer browser test automation from any language on any\nplatform. However, they do their thing in radically different ways. Selenium\nuses the strategy that JavaScript is the one common tool available for\nautomating all browsers, even though its capabilities can be highly\nconstrained. Meanwhile, WebDriver leverages the strategy that acknowledges\ndifferent automation strategies work best for different browsers. COM works\nbest for IE on Windows, Apple Events for Safari on OS X. And Firefox, well,\nthe best way to natively automate Firefox is to turn it into a telnet server.\n(But that's a whole other PyCon talk entirely!) WebDriver aims to natively\ndrive each browser the best way possible for maximum capability, then hiding\nthose differences between lower level C and C++ APIs, and finally exposing the\nfunctionality through the appropriate C/C++ mechanism for each target\nlanguage, such as using ctypes for Python. With WebDriver's technical\napproach, anything a user can do is now possible in test automation code.\n\nThis talk will go into detail explaining how Selenium and WebDriver (aka\nSelenium 2) work, comparing the strengths and weaknesses of each tool's\napproach to browser automation. The talk will then explain what Selenium 2.0\nlooks like and how to use it.\n\nTalk outline:\n\n  * Description of problem space \n    * More browsers \n    * More frequent browser releases \n    * HTML 5 - video, canvas, offline storage \n    * The web in more places - Mobile, Chrome OS \n  * Description of Selenium \n  * Strengths of Selenium \n  * Description of challenges for Selenium 1 \n    * Javascript security sandbox \n    * Same origin policy / cross-site scripting \n    * OS-level popups \n    * Speed / stability \n    * Java as the cross-language integration point (aka Not Very Pythonic, eh?) \n  * Description of Selenium 2 (aka WebDriver) \n  * Strengths of Selenium 2 \n  * How Selenium 2 is more pythonic \n    * (Lots and lots of example code goes here.) \n    * Spoiler Alert: No Java server required! \n  * How to test Android apps \n  * How to test iPhone apps \n  * Selenium development roadmap \n\n", "quality_notes": "", "copyright_text": "Creative Commons Attribution-NonCommercial-ShareAlike 3.0", "embed": "", "thumbnail_url": "http://a.images.blip.tv/Pycon-PyCon2011TestingTheMobileAndDesktopWebWithSelenium20524.png", "duration": null, "video_ogv_length": 141105384, "video_ogv_url": null, "video_ogv_download_only": false, "video_mp4_length": null, "video_mp4_url": "http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/373_testing-the-mobile-and-desktop-web-with-selenium-2-0-better-faster-and-more-pythonicly.mp4", "video_mp4_download_only": false, "video_webm_length": null, "video_webm_url": null, "video_webm_download_only": false, "video_flv_length": null, "video_flv_url": null, "video_flv_download_only": false, "source_url": "", "whiteboard": "", "recorded": "2011-03-11", "added": "2012-02-23T04:20:00", "updated": "2014-04-08T20:28:28.044"}, {"category": "PyCon US 2011", "language": "English", "slug": "pycon-2011--testing-with-mock", "speakers": ["Michael Foord"], "tags": ["mock", "pycon", "pycon2011", "testing"], "related_urls": [], "id": 392, "state": 1, "title": "Testing with mock", "summary": "", "description": "Testing with mock\n\nPresented by Michael Foord\n\nmock is a Python testing library. It has the goal of making mocking in tests\nbrain dead simple! mock provides the Mock class and the patch decorator for\nsafely patching out the objects you are mocking in your tests. This talk will\ncover standard mocking patterns. We'll also look at some of the newer features\nin the latest release, including support for mocking magic methods.\n\nAbstract\n\nmock provides a core Mock class that removes the need to create a host of\ntrivial stubs throughout your test suite. After performing an action, you can\nmake assertions about which methods / attributes were used and arguments they\nwere called with. You can also specify return values and set specific\nattributes in the normal way.\n\n  * [http://www.voidspace.org.uk/python/mock/](http://www.voidspace.org.uk/python/mock/)\n  * [http://pypi.python.org/pypi/mock/](http://pypi.python.org/pypi/mock/)\n\nThe mock module also provides a patch() decorator that handles safely patching\nout the things you are mocking during your test.\n\nWe'll cover standard mocking patterns, and how mock makes them easy. We'll\nalso be looking at some of the newer features in the latest release, including\nthe magic method support that can be used (for example) for mocking out\nobjects used as context managers.\n\nmock is designed for \"unit test style\" testing, but is used with Python\ntesting libraries like nose and py.test.\n\nThere will be some emphasis on how *not* to use mocking in testing, and why\n'over mocking' is bad (and makes for brittle tests).\n\n", "quality_notes": "", "copyright_text": "Creative Commons Attribution-NonCommercial-ShareAlike 3.0", "embed": "", "thumbnail_url": "http://a.images.blip.tv/Pycon-PyCon2011TestingWithMock498.png", "duration": null, "video_ogv_length": 171633013, "video_ogv_url": null, "video_ogv_download_only": false, "video_mp4_length": null, "video_mp4_url": "http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/392_testing-with-mock.mp4", "video_mp4_download_only": false, "video_webm_length": null, "video_webm_url": null, "video_webm_download_only": false, "video_flv_length": null, "video_flv_url": null, "video_flv_download_only": false, "source_url": "", "whiteboard": "", "recorded": "2011-03-11", "added": "2012-02-23T04:20:00", "updated": "2014-04-08T20:28:28.045"}, {"category": "PyCon US 2011", "language": "English", "slug": "pycon-2011--the-data-structures-of-python", "speakers": ["Alex Gaynor"], "tags": ["abc", "datastructures", "dequearray", "dict", "ducktyping", "frozenset", "list", "namedtuple", "ordereddict", "orderedset", "pycon", "pycon2011", "set", "tuple"], "related_urls": [], "id": 420, "state": 1, "title": "The Data Structures of Python", "summary": "", "description": "The Data Structures of Python\n\nPresented by Alex Gaynor\n\nAny Python programmer knows about the major builtin data strcutres, lists,\ndicts, tuples, but do you always remember when you're supposed to use them? Do\nyou know about all the cool data structures hidden in the standard library?\nThis talk will be a review of the characteristics of the different data\nstructures, and a tour of idiomatic ways to use some of the structures in the\nstandard library.\n\nAbstract\n\nFirst, as a note this talk borders between survey and discuss in depth. For\neach data structure I want to cover their implementation, performance\ncharacteristics, and idiomatic usage (e.g. tuples vs. lists), a lot of them\nhave similar implementations so idiomatic usage will dominate for some of\nthem.\n\n  * The builtins (10 minutes) \n    * lists \n      * Ordered collections of any type of objects \n      * Mutable \n      * Implemented as an array of pointers \n    * tuples \n      * Ordered collections of any type of objects \n      * Immutable* \n      * Implemented as a fixed-length array of pointers \n    * dicts \n      * Unordered mapping of hashable objects to any objects \n      * Mutable \n        * Why no immutable variant\n      * Implemented as an open-addressed hash table. \n    * sets \n      * Unordered collection of hashable objects \n      * Mutable \n        * frozenset\n      * Implemented as an open-addressed hash table. \n  * The Standard Library (10 minutes) \n    * OrderedDict \n      * Ordered mapping of hashable objects to any objects \n      * Mutable \n      * Implemented as a dict with a doubly-linked list running through it. \n    * deque \n      * Ordered collection of any type of objects \n      * Mutable \n      * Implemented as an unrolled, doubly-linked list \n    * namedtuple \n      * Ordered collection of any type of objects, *also* addressable by name. \n      * Immutable \n      * Implemented as a tuple with extra properties \n    * array \n      * Like a list... but limited to \"primitve\" types. \n  * Performance characteristics. \n  * Writing your own (5 minutes) \n    * Abstract Base Classes \n      * Duck typing \n        * Why would you want to use them!\n      * What's available. \n    * OrderedSet \n      * An ordered collection of hashable objects \n      * Mutable \n      * Implemented as a set with a doubly-linked list running through it. \n  * Questions (5 minutes) \n\n", "quality_notes": "", "copyright_text": "Creative Commons Attribution-NonCommercial-ShareAlike 3.0", "embed": "", "thumbnail_url": "http://a.images.blip.tv/Pycon-PyCon2011TheDataStructuresOfPython246.png", "duration": null, "video_ogv_length": 161075055, "video_ogv_url": "http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/420_the-data-structures-of-python.ogv", "video_ogv_download_only": false, "video_mp4_length": null, "video_mp4_url": "http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/420_the-data-structures-of-python.m4v", "video_mp4_download_only": false, "video_webm_length": null, "video_webm_url": null, "video_webm_download_only": false, "video_flv_length": null, "video_flv_url": null, "video_flv_download_only": false, "source_url": "", "whiteboard": "", "recorded": "2011-03-11", "added": "2012-02-23T04:20:00", "updated": "2014-04-08T20:28:28.047"}, {"category": "PyCon US 2011", "language": "English", "slug": "pycon-2011--the-development-of-python-and-you", "speakers": ["Brian Curtin"], "tags": ["coredev", "cpython", "development", "gettinginvolved", "pycon", "pycon2011"], "related_urls": [], "id": 432, "state": 1, "title": "The Development of Python and You", "summary": "", "description": "The Development of Python and You\n\nPresented by Brian Curtin\n\nHave an inside look at what it takes to work on CPython, from getting setup\nwith the source and navigating the bug tracker, to the best practices for\nhaving your work accepted. We'll find, categorize, and fix an issue in Python\nto get you started. This talk is ideal for those who are new to open source\nprojects or are interested in the Python development process.\n\nAbstract\n\nPeople from all backgrounds, users of all platforms, and developers of all\nlevels are necessary in the development of Python. From writing code to\ndocumentation, it takes all kinds of people to make an impact. If you've used\nPython, we need you, and what better place to get involved than at PyCon?\n\n2010 saw a rise in the number of contributors to CPython, and the PSF stepped\nin to support the efforts of those wanting to get involved. Are you up for the\nchallenge? This talk dives right into what it takes to get involved, covering\nthe who, what, where, when, and why of Python development, going through the\nwhole process live.\n\nAfter the conference is over, stick around with the CPython crew and hack\naway!\n\n", "quality_notes": "", "copyright_text": "Creative Commons Attribution-NonCommercial-ShareAlike 3.0", "embed": "", "thumbnail_url": "http://a.images.blip.tv/Pycon-PyCon2011TheDevelopmentOfPythonAndYou317.png", "duration": null, "video_ogv_length": 224156396, "video_ogv_url": null, "video_ogv_download_only": false, "video_mp4_length": null, "video_mp4_url": "http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/432_the-development-of-python-and-you.mp4", "video_mp4_download_only": false, "video_webm_length": null, "video_webm_url": null, "video_webm_download_only": false, "video_flv_length": null, "video_flv_url": null, "video_flv_download_only": false, "source_url": "", "whiteboard": "", "recorded": "2011-03-11", "added": "2012-02-23T04:20:00", "updated": "2014-04-08T20:28:28.048"}, {"category": "PyCon US 2011", "language": "English", "slug": "pycon-2011--the-pyramid-faq", "speakers": ["Carlos de la Guardia"], "tags": ["pycon", "pycon2011", "pyramid"], "related_urls": [], "id": 387, "state": 1, "title": "The Pyramid FAQ", "summary": "", "description": "The Pyramid FAQ\n\nPresented by Carlos de la Guardia\n\nThe #pylons IRC channel is the most common way of giving support to users of\nthe Pyramid framework. In this talk we take away some of the most often\ndiscussed topics in the channel and give detailed answers to them.\n\nAbstract\n\nEvery development project has a few questions and doubts that seem to come up\non its support channels every now and then. The Pyramid framework is no\nexception.\n\nIn this talk, we introduce Pyramid related FAQs using the chat logs and\nproceed to discuss them in detail. Showing the logs allows us to give the talk\na lighter side and makes for an introduction to each topic based on real user\nquestions.\n\nTopics covered here include:\n\n  * Configuration objects. \n  * Object traversal versus URL dispatch. \n  * Context and views. \n  * Authentication and authorization. \n  * How much 'Zope stuff' is there in Pyramid and can we take it away? \n  * Examples of how Pyramid enables the Pylons philosophy of integrating best of breed or preferred components. \n  * The future of Pyramid and Pylons. \n\n", "quality_notes": "", "copyright_text": "Creative Commons Attribution-NonCommercial-ShareAlike 3.0", "embed": "", "thumbnail_url": "http://a.images.blip.tv/Pycon-PyCon2011ThePyramidFAQ994-532.jpg", "duration": null, "video_ogv_length": 133736688, "video_ogv_url": null, "video_ogv_download_only": false, "video_mp4_length": null, "video_mp4_url": "http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/387_the-pyramid-faq.mp4", "video_mp4_download_only": false, "video_webm_length": null, "video_webm_url": null, "video_webm_download_only": false, "video_flv_length": null, "video_flv_url": null, "video_flv_download_only": false, "source_url": "", "whiteboard": "", "recorded": "2011-03-11", "added": "2012-02-23T04:20:00", "updated": "2014-04-08T20:28:28.049"}, {"category": "PyCon US 2011", "language": "English", "slug": "pycon-2011--the-python-that-wasn--39-t", "speakers": ["Larry Hastings"], "tags": ["coredev", "cpython", "makingsausage", "pycon", "pycon2011"], "related_urls": [], "id": 406, "state": 1, "title": "The Python That Wasn't", "summary": "", "description": "The Python That Wasn't\n\nPresented by Larry Hastings\n\nOne reason for Python's success is its restraint in adding new language\nfeatures. Only the most essential changes make it--and for every change that\ngets accepted, many more are rejected. Come learn about proposed changes to\nthe Python language that failed--what, how, and why.\n\nAbstract\n\n  * Quick overview of the process \n    * First ten years: send GvR a patch \n    * The modern approach: python-ideas, write a PEP, produce a reference implementation \n  * Discuss the \"prickly\" Python community \n    * This is a good thing! Only the best ideas survive the python-dev gauntlet! \n    * They do this not because they're mean, but because they care so much. \n    * We must have eternal vigilance to prevent unnecessary changes! \n  * A survey of some changes that didn't make it \n    * The switch/case statement (PEP 3103) \n    * The \"freeze protocol\" (PEP 351) \n    * The \"dynamic attribute access\" proposal from python-dev, 2007/02 \n    * Many more possibilities await in the rejected PEPs! \n  * My message to the audience \n    * Start with a post to python-ideas, please! \n    * Don't be surprised if you get a negative reaction \n    * Don't let your fear of a negative reaction stop you from trying, necessarily \n    * Do your homework, and be your own worst critic \n\n", "quality_notes": "", "copyright_text": "Creative Commons Attribution-NonCommercial-ShareAlike 3.0", "embed": "", "thumbnail_url": "http://a.images.blip.tv/Pycon-PyCon2011ThePythonThatWasnt367.png", "duration": null, "video_ogv_length": 132000761, "video_ogv_url": null, "video_ogv_download_only": false, "video_mp4_length": null, "video_mp4_url": "http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/406_the-python-that-wasn-t.mp4", "video_mp4_download_only": false, "video_webm_length": null, "video_webm_url": null, "video_webm_download_only": false, "video_flv_length": null, "video_flv_url": null, "video_flv_download_only": false, "source_url": "", "whiteboard": "", "recorded": "2011-03-11", "added": "2012-02-23T04:20:00", "updated": "2014-04-08T20:28:28.051"}, {"category": "PyCon US 2011", "language": "English", "slug": "pycon-2011--through-the-side-channel--timing-and-", "speakers": ["Geremy Condra"], "tags": ["hacking", "hardening", "pycon", "pycon2011", "security"], "related_urls": [], "id": 423, "state": 1, "title": "Through the Side Channel: Timing and Implementation Attacks in Python", "summary": "", "description": "Through the Side Channel: Timing and Implementation Attacks in Python\n\nPresented by Geremy Condra\n\nPython's dynamic nature, large standard library, and concern for beauty over\nperformance make it an elegant and uniquely easy to use language, but they\nalso cause some unique problems. In this talk we'll explore how features\nranging from dictionaries to duck typing can become security risks,\ndemonstrate those attacks on real Python projects, and examine how you can\nprotect yourself and your code.\n\nAbstract\n\nOver the last decade, an increasing body of evidence has accumulated\nindicating that even when a system is hardened enough to provide strong\nguarantees about its high-level behavior, implementation details and\nespecially performance properties can still provide attackers with an easy way\nin. For Python, this is especially problematic: its generally high-level view\nand the emphasis placed on flexibility often mean that it can be difficult to\nstop attackers from gaining a foothold, while its comparatively low execution\nspeed increases the efficacy of wide variety of implementation and timing\nattacks.\n\nTo help Pythonistas understand and cope with these problems, we've divided\nthis talk into two parts: in the first, we demonstrate the attacks against a\nseries of widely-deployed Python projects with the goal of both improving\nawareness about the issue and demonstrating common weaknesses to be avoided.\nThe second demonstrates effective countermeasures and alternative\nconstructions with the goal of improving defenders' odds of spotting and\ncorrecting these flaws in their own code.\n\n", "quality_notes": "", "copyright_text": "Creative Commons Attribution-NonCommercial-ShareAlike 3.0", "embed": "", "thumbnail_url": "http://a.images.blip.tv/Pycon-PyCon2011ThroughTheSideChannelTimingAndImplementationAt601.png", "duration": null, "video_ogv_length": 159382259, "video_ogv_url": null, "video_ogv_download_only": false, "video_mp4_length": null, "video_mp4_url": "http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/423_through-the-side-channel-timing-and-implementation-attacks-in-python.mp4", "video_mp4_download_only": false, "video_webm_length": null, "video_webm_url": null, "video_webm_download_only": false, "video_flv_length": null, "video_flv_url": null, "video_flv_download_only": false, "source_url": "", "whiteboard": "", "recorded": "2011-03-11", "added": "2012-02-23T04:20:00", "updated": "2014-04-08T20:28:28.052"}, {"category": "PyCon US 2011", "language": "English", "slug": "pycon-2011--tuf--secure-software-updates-in-pytho", "speakers": ["Geremy Condra"], "tags": ["pycon", "pycon2011", "security", "tuf", "updates"], "related_urls": [], "id": 412, "state": 1, "title": "TUF: Secure Software Updates in Python", "summary": "", "description": "TUF: Secure Software Updates in Python\n\nPresented by Geremy Condra\n\nFrom an attacker's point of view there are few entry points with as much to\noffer as a vulnerable software updater, yet history tells us that such\nvulnerabilities are common. In this talk we'll demonstrate a number of\nattacks, explain how common approaches fail to defend against them, and\ndemonstrate a pure Python library (TUF) that provides both robust protection\nand extreme ease of use.\n\nAbstract\n\nVulnerabilities in software update systems expose users to huge range of\npotential security risks, including:\n\n  * Freeze attacks, \n  * Mix-and-match attacks, \n  * Rollback attacks, and \n  * Endless data attacks \n\nIn the first part of this talk, we'll demonstrate each of these against real-\nworld software updaters and explain how commonly used countermeasures fail in\napplication. We'll then move on to the second part of the talk, demonstrating\nTUF, its internals, and the mechanisms it uses to additionally defend against\nkey compromise. Finally, we'll demonstrate how easy it is to integrate TUF\ninto your application and its lifecycle.\n\n", "quality_notes": "", "copyright_text": "Creative Commons Attribution-NonCommercial-ShareAlike 3.0", "embed": "", "thumbnail_url": "http://a.images.blip.tv/Pycon-PyCon2011TUFSecureSoftwareUpdatesInPython643-944.jpg", "duration": null, "video_ogv_length": 147096471, "video_ogv_url": null, "video_ogv_download_only": false, "video_mp4_length": null, "video_mp4_url": "http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/412_tuf-secure-software-updates-in-python.mp4", "video_mp4_download_only": false, "video_webm_length": null, "video_webm_url": null, "video_webm_download_only": false, "video_flv_length": null, "video_flv_url": null, "video_flv_download_only": false, "source_url": "", "whiteboard": "", "recorded": "2011-03-11", "added": "2012-02-23T04:20:00", "updated": "2014-04-08T20:28:28.053"}, {"category": "PyCon US 2011", "language": "English", "slug": "pycon-2011--units-need-testing-too", "speakers": ["Gary Bernhardt"], "tags": ["pycon", "pycon2011", "pyunit", "testing", "unittests"], "related_urls": [], "id": 422, "state": 1, "title": "Units Need Testing Too", "summary": "", "description": "Units Need Testing Too\n\nPresented by Gary Bernhardt\n\nPython's long history of testing has focused primarily on integration- and\nsystem-level tests: slow-running tests executing lots of code. These are a\ngreat start, but many of them can be transformed into unit-level tests. True\nunit tests are orders of magnitude faster (about 1ms each), providing quicker\nfeedback and better failure localization. We'll look at why and how to write\nthem.\n\nAbstract\n\nPython has a wonderful legacy in testing: PyUnit has been in the standard\nlibrary since March, 2001, and it was already a year old by then. We adopted\nbrowser driving quickly, and we do it at huge scale with great test\nparallelization infrastructure.\n\nBig tests aren't everything, though. In the Python world, true unit tests are\nsomewhat rare, and even most tests written with the unittest library are\nintegration tests. These tests are slow to execute and don't localize failure\nas well as smaller, focused tests. They leave us with two options: either run\nthem rarely, sacrificing feedback, or run them often, sacrificing speed.\n\nWriting true unit tests removes that particular trade-off. When your tests\nexecute in a millisecond each, you can afford to run a thousand of them every\ntime you save a source file. This talk will discuss what unit tests really\nare, why they matter, and how to write them in Python.\n\n", "quality_notes": "", "copyright_text": "Creative Commons Attribution-NonCommercial-ShareAlike 3.0", "embed": "", "thumbnail_url": "http://a.images.blip.tv/Pycon-PyCon2011UnitsNeedTestingToo863.png", "duration": null, "video_ogv_length": 176895138, "video_ogv_url": null, "video_ogv_download_only": false, "video_mp4_length": null, "video_mp4_url": "http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/422_units-need-testing-too.mp4", "video_mp4_download_only": false, "video_webm_length": null, "video_webm_url": null, "video_webm_download_only": false, "video_flv_length": null, "video_flv_url": null, "video_flv_download_only": false, "source_url": "", "whiteboard": "", "recorded": "2011-03-11", "added": "2012-02-23T04:20:00", "updated": "2014-04-08T20:28:28.054"}, {"category": "PyCon US 2011", "language": "English", "slug": "pycon-2011--useful-namespaces--context-managers-a", "speakers": ["Jack Diederich"], "tags": ["contextmanagers", "decorators", "namespaces", "pycon", "pycon2011"], "related_urls": [], "id": 395, "state": 1, "title": "Useful Namespaces: Context Managers and Decorators", "summary": "", "description": "Useful Namespaces: Context Managers and Decorators\n\nPresented by Jack Diederich\n\nPython has two useful conventions for \"I mean it, but only here\" and you can\nsay it with Context Managers and Decorators. Both give you the power to define\na push/pop of a resource for a set period inside a namespace, be it a function\nor a level of indentation. This talk is a list of patterns that are\nimplemented by one or the other (including some clever functions that are\nboth).\n\nAbstract\n\n  * Decorators, formal definition. \n  * Context Managers, formal definition. \n  * Informal definition: both have the opportunity to do and then undo. - very similar to C++ RIIA \"Resource Acquisition Is Initialization.\" - Context Managers were designed to do that but decorators are frequently just as good. \n  * Which one to use use when is all about namespaces. - Context Managers manipulate at the block level. - Function Decorators manipulate the function level. - Class Decorators manipulate at the class level. \n  * Recipes on writing decorators and context managers - Familiar examples from Django and Mock. \n\n", "quality_notes": "", "copyright_text": "Creative Commons Attribution-NonCommercial-ShareAlike 3.0", "embed": "", "thumbnail_url": "http://a.images.blip.tv/Pycon-PyCon2011UsefulNamespacesContextManagersAndDecorators353.png", "duration": null, "video_ogv_length": 127109542, "video_ogv_url": null, "video_ogv_download_only": false, "video_mp4_length": null, "video_mp4_url": "http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/395_useful-namespaces-context-managers-and-decorators.mp4", "video_mp4_download_only": false, "video_webm_length": null, "video_webm_url": null, "video_webm_download_only": false, "video_flv_length": null, "video_flv_url": null, "video_flv_download_only": false, "source_url": "", "whiteboard": "", "recorded": "2011-03-11", "added": "2012-02-23T04:20:00", "updated": "2014-04-08T20:28:28.056"}, {"category": "PyCon US 2011", "language": "English", "slug": "pycon-2011--using-blender--39-s-new-bpy-python-ap", "speakers": ["Christopher Allan Webber"], "tags": ["blender", "bpy", "chriswebber", "pycon", "pycon2011"], "related_urls": [], "id": 411, "state": 1, "title": "Using Blender's new BPY Python API", "summary": "Blender 2.5 (a free and open source software 3d graphics suite) includes a new\nBPY python API which is usable for scripting modeling, animation, etc. Learn\nto use this API to speed up your workflow, create procedural graphics, and\ncool new tools.\n\n", "description": "Since 2.5, the API has become more pythonic and self-descriptive. Blender's UI\ncan show you the Python equivalent for nearly every user action and includes a\nfull datablock exploration tool. Users will be taught how to use so they can\nquickly adapt to their appropriate needs with a little Blender experience and\nno previous BPY experience.\n\nThere will be a brief Blender overview, an introduction to the API and how to\nuse it, as well as / along with an overview of some of the presenter's own\ntools / use cases. Some other popular 3rd party Python tools will also be\nshown as an example.\n\nIf there is time, a brief demo of the Blender Game Engine will also be given,\nthough that is a separate API.\n\n", "quality_notes": "", "copyright_text": "Creative Commons Attribution-NonCommercial-ShareAlike 3.0", "embed": "", "thumbnail_url": "http://a.images.blip.tv/Pycon-PyCon2011UsingBlendersNewBPYPythonAPI450.png", "duration": null, "video_ogv_length": 150937361, "video_ogv_url": null, "video_ogv_download_only": false, "video_mp4_length": null, "video_mp4_url": "http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/411_using-blender-s-new-bpy-python-api.mp4", "video_mp4_download_only": false, "video_webm_length": null, "video_webm_url": null, "video_webm_download_only": false, "video_flv_length": null, "video_flv_url": null, "video_flv_download_only": false, "source_url": "", "whiteboard": "", "recorded": "2011-03-11", "added": "2012-02-23T04:20:00", "updated": "2014-04-08T20:28:28.057"}, {"category": "PyCon US 2011", "language": "English", "slug": "pycon-2011--using-coroutines-to-create-efficient-", "speakers": ["Matt Spitz"], "tags": ["coroutines", "gevent", "gunicorn", "highconcurrency", "libevent", "pycon", "pycon2011", "wsgi"], "related_urls": [], "id": 377, "state": 1, "title": "Using Coroutines to Create Efficient, High-Concurrency Web Applications", "summary": "", "description": "Using Coroutines to Create Efficient, High-Concurrency Web Applications\n\nPresented by Matt Spitz\n\nCreating high-concurrency python web applications is inherently difficult for\na variety of reasons. In this talk, I'll discuss the various iterations of\napplication server paradigms we've used at meebo, the advantages/disadvantages\nof each approach, and why we've settled on a coroutine-based WSGI setup to\nhandle our high-concurrency web applications going forward.\n\nAbstract\n\nThere are a number of ways in which to create a web application in python.\nSome examples include a straight-up CGI scripts that run anew with each\nrequest, preforked Apache workers that each handle multiple requests, and\nusing an asynchronous web framework like Twisted.\n\nAt meebo, we've settled on using gunicorn, a lightweight WSGI server, which\nsupports gevent, a coroutine-based network library for python. Gevent\nmonkeypatches python's system modules to make network requests asynchronous\nusing an event loop based on libevent. This trick allows the developer to use\na simple blocking CGI as a non-blocking web application that can handle many\nconcurrent requests.\n\nI'll discuss our iteration process through these approaches to building web\napplications, why we ended up choosing gunicorn+gevent, the challenges this\nnew framework presents, and how we've dealt with them.\n\n", "quality_notes": "", "copyright_text": "Creative Commons Attribution-NonCommercial-ShareAlike 3.0", "embed": "", "thumbnail_url": "http://a.images.blip.tv/Pycon-PyCon2011UsingCoroutinesToCreateEfficientHighConcurrency731.png", "duration": null, "video_ogv_length": 195851560, "video_ogv_url": null, "video_ogv_download_only": false, "video_mp4_length": null, "video_mp4_url": "http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/377_using-coroutines-to-create-efficient-high-concurrency-web-applications.mp4", "video_mp4_download_only": false, "video_webm_length": null, "video_webm_url": null, "video_webm_download_only": false, "video_flv_length": null, "video_flv_url": null, "video_flv_download_only": false, "source_url": "", "whiteboard": "", "recorded": "2011-03-11", "added": "2012-02-23T04:20:00", "updated": "2014-04-08T20:28:28.058"}, {"category": "PyCon US 2011", "language": "English", "slug": "pycon-2011--using-python-3-to-build-a-cloud-compu", "speakers": ["David Beazley"], "tags": ["pycon", "pycon2011", "soawesome", "superboard"], "related_urls": [], "id": 443, "state": 1, "title": "Using Python 3 to Build a Cloud Computing Service for my Superboard II", "summary": "", "description": "Using Python 3 to Build a Cloud Computing Service for my Superboard II\n\nPresented by David Beazley\n\nThe OSI Superboard II was the computer on which I first learned to program\nback in 1979. Python is why programming remains fun today. In this tale of old\nmeets new, I describe how I have used Python 3 to create a cloud computing\nservice for my still-working Superboard--a problem complicated by it only\nhaving 8Kb of RAM and 300-baud cassette tape audio ports for I/O.\n\nAbstract\n\nPython 3, what good is it? Cloud computing? Bah! In this talk, I describe how\nI have used Python 3 to build a distributed cloud-computing service for my\nSuperboard II system. Originally built in 1978, the Superboard is an obvious\ncandidate for cloud computing due to its extremely constrained memory (8Kb),\nslow processor (a 1Mhz 6502), crippled I/O (300 baud over audio), and retro\nprogramming environment (Microsoft Basic 1.0). The only question is how to do\nit?\n\nTo answer that question, this talk consist of two main parts. In the first\npart, I discuss the problem of building a communications stack between the\nSuperboard and a Mac using nothing but audio line-in/line-out ports--a problem\ninvolving a tricky I/O handling, real-time audio signal processing, and the\ncreation of a data-link layer communication protocol. In the second part, I\ndiscuss the creation of a distributed cloud-computing service and related\ntopics including messaging systems, key-value stores, map-reduce, etc.\n\nThe primary implementation language for all of this work is Python 3.\nThroughout the talk, I will mention interesting Python 3 programming idioms\nalong with pros and cons. I'll conclude by summarizing my experience trying to\nbuild a significant project entirely in Python 3.\n\n", "quality_notes": "", "copyright_text": "Creative Commons Attribution-NonCommercial-ShareAlike 3.0", "embed": "", "thumbnail_url": "http://a.images.blip.tv/Pycon-PyCon2011UsingPython3ToBuildACloudComputingServiceFor438.png", "duration": null, "video_ogv_length": 234095870, "video_ogv_url": null, "video_ogv_download_only": false, "video_mp4_length": null, "video_mp4_url": "http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/443_using-python-3-to-build-a-cloud-computing-service-for-my-superboard-ii.mp4", "video_mp4_download_only": false, "video_webm_length": null, "video_webm_url": null, "video_webm_download_only": false, "video_flv_length": null, "video_flv_url": null, "video_flv_download_only": false, "source_url": "", "whiteboard": "", "recorded": "2011-03-11", "added": "2012-02-23T04:20:00", "updated": "2014-04-08T20:28:28.059"}, {"category": "PyCon US 2011", "language": "English", "slug": "pycon-2011--web2py-secrets-tutorial--1-2", "speakers": ["Massimo Di Pierro"], "tags": ["pycon", "pycon2011", "web", "web2py"], "related_urls": [], "id": 433, "state": 1, "title": "web2py secrets tutorial (1/2)", "summary": "", "description": "web2py secrets\n\nPresented by Massimo Di Pierro\n\nWe will provide an introduction to web2py with particular focus on its design\nobjectives, its differences when compared to other web frameworks, and some of\nthe most recently added features (components, plugins, openid/oauth\nintegration).\n\nAbstract\n\nWeb2py is a framework for rapid web application development of secure\ndatabase-driven web applications. In this tutorial we will provide a brief\nintroduction to web2py, the web based IDE, its internal design, and its\ninternal file organization. We will explain the motivations behind some of its\nmost controversial design goals. We will also discuss in some detail its Ajax\ncapabilities by using web2py components and plugins for modular design of rich\nweb interfaces.\n\nThis will be a very concentrated version (10%) of a course (CSC438) on web\nframeworks the author teaches at DePaul University. The course has been taught\n3 times and the last time counted more than 30 students.\n\n", "quality_notes": "", "copyright_text": "Creative Commons Attribution-NoDerivs 3.0", "embed": "", "thumbnail_url": "http://a.images.blip.tv/Mdipierro-web2pyTutorialPycon201112623-523.jpg", "duration": null, "video_ogv_length": null, "video_ogv_url": null, "video_ogv_download_only": false, "video_mp4_length": null, "video_mp4_url": "http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/433_web2py-secrets-tutorial-1-2.m4v", "video_mp4_download_only": false, "video_webm_length": null, "video_webm_url": null, "video_webm_download_only": false, "video_flv_length": null, "video_flv_url": null, "video_flv_download_only": false, "source_url": "", "whiteboard": "", "recorded": "2011-03-11", "added": "2012-02-23T04:20:00", "updated": "2014-04-08T20:28:28.061"}, {"category": "PyCon US 2011", "language": "English", "slug": "pycon-2011--what-would-you-do-with-an-ast", "speakers": ["Matthew J Desmarais"], "tags": ["ast", "pycon", "pycon2011"], "related_urls": [], "id": 419, "state": 1, "title": "What would you do with an ast?", "summary": "", "description": "What would you do with an ast?\n\nPresented by Matthew J Desmarais\n\nThe ast module in the Python (>= 2.6) standard library provides a\nrepresentation of python code in a python data structure. We'll begin with a\ndiscussion about what an abstract syntax tree is and why it's useful. We can\nthen talk about what's available in the ast module, how it works, and how you\ncan use it. This will be a practical session built around examples examining\nand modifying live ASTs.\n\nAbstract\n\nI would prefer to make this a 45 minute talk with examination of code samples.\n\nPython 2.6 introduced a new module in the standard library, ast. The first\nline of the ast documentation is, \"The ast module helps Python applications to\nprocess trees of the Python abstract syntax grammar.\" What this means is not\nobvious and many, if not most, python programmers won't know what this means.\nI will begin by talking about the idea of syntax tree and how it fits into the\npython execution lifecycle. I will also talk about the contents of the ast\nmodule. I will cover the available ast.Node subclasses and the provided helper\nfunctions, including the NodeVisitor and NodeTransformer. I will finish by\ntalking about how the ast module can be used to analyze Python code and how it\ncan be used to generate new code.\n\nI expect the time to break down roughly like this:\n\nIntroduction ( 5m )\n\n  * Capacitor joke \n  * What is an abstract syntax tree? \n  * How they are used by the Python interpreter \n\nThe contents of the ast module (20 m)\n\n  * The node subclasses and the ast ( 10m ) \n    * How you get an ast. \n      * code examples\n    * ast.stmt vs. ast.expr \n    * peculiarities \n      * code examples \n        * elif as syntactic sugar for \"if: else: if:\" \n        * comparison operators \n    * Why this is useful. \n      * the ast is the \"truth\" of the program \n        * code examples \n        * tricky code \n  * The ast module helpers ( 10m ) \n    * visitor pattern \n    * NodeVisitor \n    * NodeTransformer \n    * code examples \n\nWhat you do with an ast ( 15m )\n\n  * Walking an ast \n    * code examples \n      * a simple visitor to gather variables by scope\n  * Creating/Modifying an ast \n    * code examples \n      * rearrange imports transformer \n      * naive \"rename all instances\" transformer \n      * naive macro expansion transformer \n\nConclusion ( 5m )\n\n  * Practical Applications \n    * existing projects \n      * visitors \n        * checkers (pylint, pyflakes)\n      * transformers \n        * refactoring tools (rope)\n  * When is it a good idea to use ast? \n\n", "quality_notes": "", "copyright_text": "Creative Commons Attribution-NonCommercial-ShareAlike 3.0", "embed": "", "thumbnail_url": "http://a.images.blip.tv/Pycon-PyCon2011WhatWouldYouDoWithAnAst198.png", "duration": null, "video_ogv_length": 220279145, "video_ogv_url": null, "video_ogv_download_only": false, "video_mp4_length": null, "video_mp4_url": "http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/419_what-would-you-do-with-an-ast.mp4", "video_mp4_download_only": false, "video_webm_length": null, "video_webm_url": null, "video_webm_download_only": false, "video_flv_length": null, "video_flv_url": null, "video_flv_download_only": false, "source_url": "", "whiteboard": "", "recorded": "2011-03-11", "added": "2012-02-23T04:20:00", "updated": "2014-04-08T20:28:28.062"}, {"category": "PyCon US 2011", "language": "English", "slug": "pycon-2011--why-is-python-slow-and-how-pypy-can-h", "speakers": ["Alex Gaynor", "Maciej Fijalkowski"], "tags": ["jit", "pycon", "pycon2011", "pypy", "vm"], "related_urls": [], "id": 427, "state": 1, "title": "Why is Python slow and how PyPy can help?", "summary": "", "description": "Why is Python slow and how PyPy can help?\n\nPresented by Maciej Fijalkowski and Alex Gaynor\n\nPyPy is a virtual machine for Python, featuring an advanced just in time\ncompiler, which can deliver exceptional performance. This talk is going to be\na deep dive into what exactly makes Python such a hard language to optimize,\nhow PyPy is organized, and what optimizations our JIT can do (and what it\ncan't do) for your code.\n\nAbstract\n\nThe talk will detail how a python interpreter works internally and why some\noperations are costly. We'll go through several python features, how they\nwork, why they're slow in CPython and how we're fixing it.\n\nThe list of mentioned features is not exhaustive, however we will try to focus\nat least on the following:\n\n  * Dynamic language - In Python code we have no known types, like a statically typed language. Even operations like \"a + b\" can do anything, unless we know more about the code, and the types it is operating on.\n\n  * Frame introspection - Frame objects need to be allocated for every function call, and all local variables are stored on the frame, and must be accessible from further down the call stack.\n\nPyPy uses a novel approach called \"virtualizables\" which makes it possible to\navoid frame allocation in most common cases.\n\n  * Object model - All user defined Python objects have a dictionary which stores their attributes, as does every type. When Python does an attribute lookup this requires at least two dictionary lookups.\n\nIn PyPy we use an approach similar to the one used by V8 with hidden classes\n(except more PyPy specific) called map dictionaries and other optimizations.\n\n  * FFI calls - Calling C from Python is costly and hard to optimize. In PyPy we expose C APIs to Python code via ctypes. This part explains how we can optimize ctypes calls.\n\n  * array module - Users of CPython's array module probably know it can save them quite a bit of memory, however it's also slower than using a list, due to the overhead of boxing and unboxing on every operations. Here we will tie everything together and describe how the array module is much faster with PyPy's JIT, combining our optimizations to: unbox values, remove the dynamicism within traces, and deliver great performance.\n\n", "quality_notes": "", "copyright_text": "Creative Commons Attribution-NonCommercial-ShareAlike 3.0", "embed": "", "thumbnail_url": "http://a.images.blip.tv/Pycon-PyCon2011WhyIsPythonSlowAndHowPyPyCanHelp525.png", "duration": null, "video_ogv_length": 154529169, "video_ogv_url": null, "video_ogv_download_only": false, "video_mp4_length": null, "video_mp4_url": "http://05d2db1380b6504cc981-8cbed8cf7e3a131cd8f1c3e383d10041.r93.cf2.rackcdn.com/pycon-us-2011/427_why-is-python-slow-and-how-pypy-can-help.mp4", "video_mp4_download_only": false, "video_webm_length": null, "video_webm_url": "", "video_webm_download_only": false, "video_flv_length": null, "video_flv_url": "", "video_flv_download_only": false, "source_url": "", "whiteboard": "", "recorded": "2011-03-11", "added": "2012-02-23T04:20:00", "updated": "2014-04-08T20:28:28.063"}]}