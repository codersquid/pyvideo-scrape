{"count": 3439, "next": "http://pyvideo.org/api/v2/video/?page=52&format=json", "previous": "http://pyvideo.org/api/v2/video/?page=50&format=json", "results": [{"category": "PyCon Ukraine 2014", "language": "Russian", "slug": "linux-containers-ecosystem", "speakers": ["Paul Colomiets"], "tags": [], "related_urls": [], "id": 3352, "state": 1, "title": "LINUX CONTAINERS ECOSYSTEM", "summary": "", "description": "Docker changed the way we do development and deployment. But most people use it as a black box that do the job most of the time. This is advanced level talk that explains how linux containers work in depth. What new perspectives they open. And what new challenges they impose. After this lecture you might be able to implement your own Docker or to build more sophisticated tools on top of linux containers.\r\nIt consists of three parts:\r\n\r\n\r\n  1. Internals of linux namespaces: system calls and other things behind containers\r\n  2. Overview of different container implementations: docker, lxc, vagrant-lxc, nix...\r\n  3. New security challenges of namespaces with great emphasis on Docker and clouds ", "quality_notes": "", "copyright_text": "youtube", "embed": "<iframe type='text/html' src='http://www.youtube.com/embed/bDRk_LCpN1Q' width='640' height='360' frameborder='0' allowfullscreen='true'/>", "thumbnail_url": "https://i.ytimg.com/vi/bDRk_LCpN1Q/hqdefault.jpg", "duration": null, "video_ogv_length": null, "video_ogv_url": "", "video_ogv_download_only": false, "video_mp4_length": null, "video_mp4_url": "", "video_mp4_download_only": false, "video_webm_length": null, "video_webm_url": "", "video_webm_download_only": false, "video_flv_length": null, "video_flv_url": "", "video_flv_download_only": false, "source_url": "https://www.youtube.com/watch?v=bDRk_LCpN1Q", "whiteboard": "", "recorded": "2014-11-02", "added": "2014-11-26T17:50:50.790", "updated": "2014-11-27T16:18:47.393"}, {"category": "PyCon Ukraine 2014", "language": "Russian", "slug": "product-buidling-101", "speakers": ["Max Ischenko"], "tags": [], "related_urls": [], "id": 3350, "state": 1, "title": "Product buidling 101", "summary": "", "description": "", "quality_notes": "", "copyright_text": "youtube", "embed": "<iframe type='text/html' src='http://www.youtube.com/embed/SNu11Vyy8Kk' width='640' height='360' frameborder='0' allowfullscreen='true'/>", "thumbnail_url": "https://i.ytimg.com/vi/SNu11Vyy8Kk/hqdefault.jpg", "duration": null, "video_ogv_length": null, "video_ogv_url": "", "video_ogv_download_only": false, "video_mp4_length": null, "video_mp4_url": "", "video_mp4_download_only": false, "video_webm_length": null, "video_webm_url": "", "video_webm_download_only": false, "video_flv_length": null, "video_flv_url": "", "video_flv_download_only": false, "source_url": "https://www.youtube.com/watch?v=SNu11Vyy8Kk", "whiteboard": "", "recorded": "2014-11-02", "added": "2014-11-26T17:50:50.616", "updated": "2014-11-29T12:43:46.095"}, {"category": "PyCon Ukraine 2014", "language": "Russian", "slug": "python-on-azure-the-beginning", "speakers": ["Anton Boyko"], "tags": [], "related_urls": [], "id": 3347, "state": 1, "title": "Python on Azure, the beginning.", "summary": "", "description": "", "quality_notes": "", "copyright_text": "youtube", "embed": "<iframe type='text/html' src='http://www.youtube.com/embed/OHC9-C062v8' width='640' height='360' frameborder='0' allowfullscreen='true'/>", "thumbnail_url": "https://i.ytimg.com/vi/OHC9-C062v8/hqdefault.jpg", "duration": null, "video_ogv_length": null, "video_ogv_url": "", "video_ogv_download_only": false, "video_mp4_length": null, "video_mp4_url": "", "video_mp4_download_only": false, "video_webm_length": null, "video_webm_url": "", "video_webm_download_only": false, "video_flv_length": null, "video_flv_url": "", "video_flv_download_only": false, "source_url": "https://www.youtube.com/watch?v=OHC9-C062v8", "whiteboard": "", "recorded": "2014-11-02", "added": "2014-11-26T17:50:50.355", "updated": "2014-11-27T16:20:15.878"}, {"category": "PyCon Ukraine 2014", "language": "Russian", "slug": "konstantin-danilov-web-services-that-store-data", "speakers": ["Konstantin Danilov"], "tags": [], "related_urls": [], "id": 3353, "state": 1, "title": "Web-services that store data in RAM", "summary": "", "description": "", "quality_notes": "", "copyright_text": "youtube", "embed": "<iframe type='text/html' src='http://www.youtube.com/embed/fhRe_TO0E0k' width='640' height='360' frameborder='0' allowfullscreen='true'/>", "thumbnail_url": "https://i.ytimg.com/vi/fhRe_TO0E0k/hqdefault.jpg", "duration": null, "video_ogv_length": null, "video_ogv_url": "", "video_ogv_download_only": false, "video_mp4_length": null, "video_mp4_url": "", "video_mp4_download_only": false, "video_webm_length": null, "video_webm_url": "", "video_webm_download_only": false, "video_flv_length": null, "video_flv_url": "", "video_flv_download_only": false, "source_url": "https://www.youtube.com/watch?v=fhRe_TO0E0k", "whiteboard": "", "recorded": "2014-11-02", "added": "2014-11-26T17:50:50.892", "updated": "2014-11-27T16:20:38.662"}, {"category": "PyCon Ukraine 2014", "language": "Russian", "slug": "asynchronous-programming-with-new-asyncio-module", "speakers": ["Alexei Popravka"], "tags": [], "related_urls": [], "id": 3345, "state": 1, "title": "ASYNCHRONOUS PROGRAMMING WITH NEW ASYNCIO MODULE.", "summary": "", "description": "", "quality_notes": "", "copyright_text": "youtube", "embed": "<iframe type='text/html' src='http://www.youtube.com/embed/K0KOvAc201M' width='640' height='360' frameborder='0' allowfullscreen='true'/>", "thumbnail_url": "https://i.ytimg.com/vi/K0KOvAc201M/hqdefault.jpg", "duration": null, "video_ogv_length": null, "video_ogv_url": "", "video_ogv_download_only": false, "video_mp4_length": null, "video_mp4_url": "", "video_mp4_download_only": false, "video_webm_length": null, "video_webm_url": "", "video_webm_download_only": false, "video_flv_length": null, "video_flv_url": "", "video_flv_download_only": false, "source_url": "https://www.youtube.com/watch?v=K0KOvAc201M", "whiteboard": "", "recorded": "2014-11-01", "added": "2014-11-26T17:50:49.791", "updated": "2014-11-27T16:21:01.845"}, {"category": "PyCon Ukraine 2014", "language": "Russian", "slug": "how-we-are-recognizing-shredded-documents-of-yanu", "speakers": ["Dmitry Chaplinsky"], "tags": [], "related_urls": [{"url": "http://unshred.it/", "description": ""}], "id": 3348, "state": 1, "title": "How we are recognizing shredded documents of Yanukovich and Kurchenko", "summary": "", "description": "\u0420\u0430\u0441\u0441\u043a\u0430\u0437 \u043e \u0442\u043e\u043c, \u043a\u0430\u043a \u043c\u044b \u0433\u0440\u0443\u043f\u043f\u043e\u0439 \u0432\u043e\u043b\u043e\u043d\u0442\u0435\u0440\u043e\u0432 \u043f\u0440\u0438 \u043f\u043e\u043c\u043e\u0449\u0438 Python, crowdsourcing, open source \u0438 OpenCV \u043f\u044b\u0442\u0430\u0435\u043c\u0441\u044f \u0440\u0435\u0448\u0438\u0442\u044c \u0437\u0430\u0434\u0430\u0447\u0443 \u043f\u043e \u0441\u0431\u043e\u0440\u0443 \u0441\u0430\u043c\u043e\u0433\u043e \u0431\u043e\u043b\u044c\u0448\u043e\u0433\u043e \u043f\u0430\u0437\u0437\u043b\u0430 \u0432 \u043c\u0438\u0440\u0435: 50 \u043c\u0435\u0448\u043a\u043e\u0432 \u0434\u043e\u043a\u0443\u043c\u0435\u043d\u0442\u043e\u0432 \u043e\u043b\u0438\u0433\u0430\u0440\u0445\u0430 \u041a\u0443\u0440\u0447\u0435\u043d\u043a\u043e, \u043f\u0440\u043e\u043f\u0443\u0449\u0435\u043d\u043d\u044b\u0445 \u0447\u0435\u0440\u0435\u0437 \u0448\u0440\u0435\u0434\u0435\u0440\u044b. \u0421\u0440\u044b\u0432\u044b \u043f\u043e\u043a\u0440\u043e\u0432\u043e\u0432, \u0440\u0430\u0437\u0432\u0435\u043d\u0447\u0430\u043d\u0438\u044f \u043f\u043e\u043f\u0443\u043b\u044f\u0440\u043d\u044b\u0445 \u0437\u0430\u0431\u043b\u0443\u0436\u0434\u0435\u043d\u0438\u0439, \u0441\u0435\u043a\u0440\u0435\u0442\u044b \u043f\u043e\u0431\u0435\u0434\u0438\u0442\u0435\u043b\u0435\u0439 Darpa Shredder Challenge. \u041d\u0430\u0448 \u043f\u043e\u0434\u0445\u043e\u0434: \u043e\u0431\u0449\u0430\u044f \u0438\u0434\u0435\u044f, \u043c\u0435\u0442\u043e\u0434\u0438\u043a\u0430 \u0440\u0435\u0448\u0435\u043d\u0438\u044f, \u0442\u0435\u0445\u043d\u0438\u0447\u0435\u0441\u043a\u0438\u0435 \u0441\u0440\u0435\u0434\u0441\u0442\u0432\u0430, \u0438\u0434\u0435\u0438 \u0434\u0430\u043b\u044c\u043d\u0435\u0439\u0448\u0435\u0433\u043e \u0440\u0430\u0437\u0432\u0438\u0442\u0438\u044f. \u0410 \u0442\u0430\u043a\u0436\u0435 \u043f\u044f\u0442\u044c \u043c\u0438\u043d\u0443\u0442 \u0431\u0435\u0437\u0443\u0434\u0435\u0440\u0436\u043d\u043e\u0433\u043e \u0445\u0430\u0439\u0440\u0430 \u0432 open source \u043f\u0440\u043e\u0435\u043a\u0442.", "quality_notes": "", "copyright_text": "youtube", "embed": "<iframe type='text/html' src='http://www.youtube.com/embed/QT7Gy4vCWms' width='640' height='360' frameborder='0' allowfullscreen='true'/>", "thumbnail_url": "https://i.ytimg.com/vi/QT7Gy4vCWms/hqdefault.jpg", "duration": null, "video_ogv_length": null, "video_ogv_url": "", "video_ogv_download_only": false, "video_mp4_length": null, "video_mp4_url": "", "video_mp4_download_only": false, "video_webm_length": null, "video_webm_url": "", "video_webm_download_only": false, "video_flv_length": null, "video_flv_url": "", "video_flv_download_only": false, "source_url": "https://www.youtube.com/watch?v=QT7Gy4vCWms", "whiteboard": "", "recorded": "2014-11-01", "added": "2014-11-26T17:50:50.453", "updated": "2014-11-27T16:21:23.379"}, {"category": "EuroScipy 2014", "language": "English", "slug": "accelerating-random-forests-in-scikit-learn", "speakers": ["Gilles Louppe"], "tags": [], "related_urls": [], "id": 3334, "state": 1, "title": "Accelerating Random Forests in Scikit Learn", "summary": "", "description": "Random Forests are without contest one of the most robust, accurate and versatile tools for solving machine learning tasks. Implementing this algorithm properly and efficiently remains however a challenging task involving issues that are easily overlooked if not considered with care. In this talk, we present the Random Forests implementation developed within the Scikit-Learn machine learning library. In particular, we describe the iterative team efforts that led us to gradually improve our codebase and eventually make Scikit-Learn's Random Forests one of the most efficient implementations in the scientific ecosystem, across all libraries and programming languages. Algorithmic and technical optimizations that have made this possible include:\r\n\r\n* An efficient formulation of the decision tree algorithm, tailored for Random Forests;\r\n* Cythonization of the tree induction algorithm;\r\n* CPU cache optimizations, through low-level organization of data into contiguous memory blocks;\r\n* Efficient multi-threading through GIL-free routines;\r\n* A dedicated sorting procedure, taking into account the properties of data;\r\n* Shared pre-computations whenever critical.\r\n\r\nOverall, we believe that lessons learned from this case study extend to a broad range of scientific applications and may be of interest to anybody doing data analysis in Python.", "quality_notes": "", "copyright_text": "youtube", "embed": "<iframe type='text/html' src='http://www.youtube.com/embed/TqF0rKzvjm4' width='640' height='360' frameborder='0' allowfullscreen='true'/>", "thumbnail_url": "https://i.ytimg.com/vi/TqF0rKzvjm4/hqdefault.jpg", "duration": null, "video_ogv_length": null, "video_ogv_url": "", "video_ogv_download_only": false, "video_mp4_length": null, "video_mp4_url": "", "video_mp4_download_only": false, "video_webm_length": null, "video_webm_url": "", "video_webm_download_only": false, "video_flv_length": null, "video_flv_url": "", "video_flv_download_only": false, "source_url": "https://www.youtube.com/watch?v=TqF0rKzvjm4", "whiteboard": "", "recorded": "2014-10-22", "added": "2014-11-05T22:41:04.483", "updated": "2014-11-05T22:42:28.662"}, {"category": "EuroScipy 2014", "language": "English", "slug": "advanced-python-profiling", "speakers": ["Yury V Zaytsev"], "tags": [], "related_urls": [], "id": 3329, "state": 1, "title": "Advanced Python Profiling", "summary": "", "description": "", "quality_notes": "", "copyright_text": "youtube", "embed": "<iframe type='text/html' src='http://www.youtube.com/embed/DUCMjsrYSrQ' width='640' height='360' frameborder='0' allowfullscreen='true'/>", "thumbnail_url": "https://i.ytimg.com/vi/DUCMjsrYSrQ/hqdefault.jpg", "duration": null, "video_ogv_length": null, "video_ogv_url": "", "video_ogv_download_only": false, "video_mp4_length": null, "video_mp4_url": "", "video_mp4_download_only": false, "video_webm_length": null, "video_webm_url": "", "video_webm_download_only": false, "video_flv_length": null, "video_flv_url": "", "video_flv_download_only": false, "source_url": "https://www.youtube.com/watch?v=DUCMjsrYSrQ", "whiteboard": "needs editing", "recorded": "2014-10-22", "added": "2014-11-05T22:41:03.963", "updated": "2014-11-05T22:41:03.963"}, {"category": "EuroScipy 2014", "language": "English", "slug": "a-python-based-post-processing-toolset-for-seismi", "speakers": ["Steve Braiser"], "tags": [], "related_urls": [], "id": 3326, "state": 1, "title": "A Python based Post processing Toolset for Seismic Analyses", "summary": "", "description": "This talk will discuss the design and implementation of a Python-based tool-set to aid in assessing the response of the UK's Advanced Gas Reactor nuclear power stations to earthquakes. The seismic analyses themselves are carried out with a commercial Finite Element solver, but understanding the raw data this produces requires customised post-processing and visualisation tools. Extending the existing tools had become increasingly difficult and a decision was made to develop a new, Python-based tool-set. This comprises of a post-processing framework (\"aftershock\") which includes an an embedded Python interpreter, and a plotting package (\"afterplot\") based on numpy and matplotlib.\r\n\r\nThe new tool-set had to be significantly more flexible and easier to maintain than the existing code-base, while allowing the majority of development to be carried out by engineers with little training in software development. The resulting architecture will be described with a focus on exploring how the design drivers were met and the successes and challenges arising from the choices made.", "quality_notes": "", "copyright_text": "youtube", "embed": "<iframe type='text/html' src='http://www.youtube.com/embed/BiqPbiWv2hY' width='640' height='360' frameborder='0' allowfullscreen='true'/>", "thumbnail_url": "https://i.ytimg.com/vi/BiqPbiWv2hY/hqdefault.jpg", "duration": null, "video_ogv_length": null, "video_ogv_url": "", "video_ogv_download_only": false, "video_mp4_length": null, "video_mp4_url": "", "video_mp4_download_only": false, "video_webm_length": null, "video_webm_url": "", "video_webm_download_only": false, "video_flv_length": null, "video_flv_url": "", "video_flv_download_only": false, "source_url": "https://www.youtube.com/watch?v=BiqPbiWv2hY", "whiteboard": "", "recorded": "2014-10-22", "added": "2014-11-05T22:41:03.354", "updated": "2014-11-05T22:41:03.354"}, {"category": "EuroScipy 2014", "language": "English", "slug": "developing-scientific-simulation-systems", "speakers": ["Mike M\u00fcller"], "tags": [], "related_urls": [], "id": 3330, "state": 1, "title": "Developing Scientific Simulation Systems", "summary": "", "description": "Scientific simulation models often need to incorporate many aspects into a\r\nworking software system. This talk gives an overview of\r\n[PITLAKQ](http://www.pitlakq.com/), a complex, coupled model for water\r\nquality predictions of pit lakes. The focus is on experiences gained that\r\nmight be useful for similar projects from other domains. This includes\r\nwrapping of legacy code, creating flexible but simple to use model input\r\napproaches and simplifying automation by users.  Description\r\n\r\nThe model PITLAKQ helps to predict the water quality of pit lakes. These\r\nlakes can form in voids created by mining and may pose considerable\r\nenvironmental challenges. PITLAKQ couples several existing numerical models\r\nand adds lots of new functionality to account for the complex interactions\r\nof hydrodynamics, geochemical processes and anthropogenic influences.\r\n\r\nObviously, there is lots of scientific details. The talk only gives a very\r\nshort overview of the functionality of the software. The main focus is on\r\ngeneral principles that can be applied to other domains of scientific\r\nmodeling. This includes:\r\n\r\n* wrapping legacy Fortran code\r\n* coupling models from different domains\r\n* creating a simple, yet flexible input system for model users\r\n* simplifying automation of simulation runs\r\n\r\nI think the lessons I learned over the last 15 years I've been working on\r\nthis project can be useful for other scientists who need to solve simulation\r\nand modeling problems in other fields.\r\n", "quality_notes": "", "copyright_text": "youtube", "embed": "<iframe type='text/html' src='http://www.youtube.com/embed/Fo2aZGDgFCM' width='640' height='360' frameborder='0' allowfullscreen='true'/>", "thumbnail_url": "https://i.ytimg.com/vi/Fo2aZGDgFCM/hqdefault.jpg", "duration": null, "video_ogv_length": null, "video_ogv_url": "", "video_ogv_download_only": false, "video_mp4_length": null, "video_mp4_url": "", "video_mp4_download_only": false, "video_webm_length": null, "video_webm_url": "", "video_webm_download_only": false, "video_flv_length": null, "video_flv_url": "", "video_flv_download_only": false, "source_url": "https://www.youtube.com/watch?v=Fo2aZGDgFCM", "whiteboard": "", "recorded": "2014-10-22", "added": "2014-11-05T22:41:04.060", "updated": "2014-11-05T22:41:04.060"}, {"category": "EuroScipy 2014", "language": "English", "slug": "efficient-large-data-operations-with-biggus", "speakers": ["Patrick Peglar"], "tags": [], "related_urls": [], "id": 3324, "state": 1, "title": "Efficient large data operations with Biggus", "summary": "Biggus is a lightweight pure-Python package which implements lazy operations on numpy array-like objects. This provides dramatically improved efficiency in analysing large datasets, for minimal additional effort in the client code.", "description": "As scientific datasets continue to grow exponentially in size, the resource requirements of even simple analyses can quickly grow to become a problem -- e.g. the job takes an unreasonably long time, or simply runs out of space.\r\n\r\nExisting solutions to this may be powerful, but can also come with a large complexity overhead, especially for the non-expert user. This makes adapting an existing analysis to the needs of larger datasets potentially very costly.\r\n\r\nBiggus provides simple abstractions of data access and calculations which provide lazy evaluation. It exposes this as simple virtual array object which mimics a numpy array. Thus, it does not require the user to re-cast an operation in unfamiliar terms, or specify unrelated details of data storage or concurrency factors.\r\n\r\nThe lazy evaluation approach allows optimised resource usage for both storage accesses and the parallelisation of calculations. Pure Python is well suited to describing and implementing these techniques, and the resulting implementation is easily accessible to the average user.\r\n\r\nAt the Met Office, we develop data analysis tools for a large community of research scientists. We developed [Biggus](https://github.com/SciTools/biggus) as a resource for the Iris project, our next-generation analysis library for meteorological and oceanographic data (see: <http://scitools.org.uk/iris/>). While Biggus is still work-in-progress, within Iris it is already delivering significant benefit, in tasks such as catalogueing large datasets and accelerating statistical calculations. Here, performance already exceeds that of other standard software toolsets.\r\n\r\n## Schedule\r\n\r\n* the problems Biggus is aiming to solve, and techniques employed\r\n* an overview of the architecture and code of the current implementation\r\n* a demonstration of current performance, in ease-of-use and efficiency benefits\r\n* suggestions for future developments; how to get involved; questions", "quality_notes": "", "copyright_text": "youtube", "embed": "<iframe type='text/html' src='http://www.youtube.com/embed/7rpcWZJaGFo' width='640' height='360' frameborder='0' allowfullscreen='true'/>", "thumbnail_url": "https://i.ytimg.com/vi/7rpcWZJaGFo/hqdefault.jpg", "duration": null, "video_ogv_length": null, "video_ogv_url": "", "video_ogv_download_only": false, "video_mp4_length": null, "video_mp4_url": "", "video_mp4_download_only": false, "video_webm_length": null, "video_webm_url": "", "video_webm_download_only": false, "video_flv_length": null, "video_flv_url": "", "video_flv_download_only": false, "source_url": "https://www.youtube.com/watch?v=7rpcWZJaGFo", "whiteboard": "", "recorded": "2014-10-22", "added": "2014-11-05T22:41:02.966", "updated": "2014-11-05T22:41:02.966"}, {"category": "EuroScipy 2014", "language": "English", "slug": "firedrake-a-high-level-portable-finite-element-c", "speakers": ["Florian Rathgeber"], "tags": [], "related_urls": [], "id": 3336, "state": 1, "title": "Firedrake: a High-level Portable Finite Element Computation Framework", "summary": "", "description": "In an ideal world, scientific applications are computationally efficient,\r\nmaintainable, composable and allow scientists to work very productively. In\r\nthis talk we demonstrate that these goals are achievable for a specific\r\napplication domain by choosing suitable domain-specific abstractions\r\nimplemented in Python that encapsulate domain knowledge with a high degree\r\nof expressiveness.\r\n\r\nWe present [Firedrake](http://firedrakeproject.org/), a high-level Python framework for the portable\r\nsolution of partial differential equations on unstructured meshes with the\r\nfinite element method widely used in science and engineering. Firedrake is\r\nbuilt on top of [PyOP2](http://op2.github.io/PyOP2), a domain-specific language embedded in Python for\r\nparallel mesh-based computations. Finite element local assembly operations\r\nexecute the same computational kernel for every element of the mesh and is\r\ntherefore efficiently parallelisable.\r\n\r\nFiredrake allows scientists to describe variational forms and\r\ndiscretisations for finite element problems symbolically in a notation very\r\nclose to the maths using the Unified Form Language [UFL](https://bitbucket.org/fenics-project/ufl/) from the [FEniCS project](http://fenicsproject.org/). Variational forms are translated into computational kernels by the\r\nFEniCS Form Compiler [FFC](https://bitbucket.org/fenics-project/ffc/). Numerical linear algebra is delegated to PETSc,\r\nleveraged via its petsc4py interface.\r\n\r\nPyOP2 abstracts away the performance-portable parallel execution of these\r\nkernels on a range of hardware architectures, targeting multi-core CPUs with\r\nOpenMP and GPUs and accelerators with PyCUDA and PyOpenCL and distributed\r\nparallel computations with mpi4py. Backend-specific code tailored to each\r\nspecific computation is generated, just-in-time compiled and efficiently\r\nscheduled for parallel execution at runtime.\r\n\r\nDue to the composability of the Firedrake and PyOP2 abstractions, optimised\r\nimplementations for different hardware architectures can be automatically\r\ngenerated without any changes to a single high-level source. Performance\r\nmatches or exceeds what is realistically attainable by hand-written code.\r\nBoth projects are open source and developed at Imperial College London.\r\n", "quality_notes": "", "copyright_text": "youtube", "embed": "<iframe type='text/html' src='http://www.youtube.com/embed/VdzE0ZBAa-Q' width='640' height='360' frameborder='0' allowfullscreen='true'/>", "thumbnail_url": "https://i.ytimg.com/vi/VdzE0ZBAa-Q/hqdefault.jpg", "duration": null, "video_ogv_length": null, "video_ogv_url": "", "video_ogv_download_only": false, "video_mp4_length": null, "video_mp4_url": "", "video_mp4_download_only": false, "video_webm_length": null, "video_webm_url": "", "video_webm_download_only": false, "video_flv_length": null, "video_flv_url": "", "video_flv_download_only": false, "source_url": "https://www.youtube.com/watch?v=VdzE0ZBAa-Q", "whiteboard": "", "recorded": "2014-10-22", "added": "2014-11-05T22:41:04.859", "updated": "2014-11-05T22:41:04.859"}, {"category": "EuroScipy 2014", "language": "English", "slug": "introducing-vispys-high-level-modules-easy-pow", "speakers": ["Almar Klein", "Cyrille Rossant", "Eric Larson", "Luke Campagnola", "Nicolas P. Rougier"], "tags": [], "related_urls": [], "id": 3327, "state": 1, "title": "Introducing Vispy's high level modules: easy, powerful visualization", "summary": "", "description": "Vispy is an OpenGL-based interactive visualization library in Python. Its goal is to make it easy to create beautiful and fast dynamic visualizations. For example, scientific plotting of tens of millions of points, interacting with complex polygonial models, and (dynamic) volume rendering.\r\n\r\nVispy is a young library and very actively developed. Until recently, a user would have to know OpenGL in order to work with Vispy. Now that the higher levels of the package take shape, this is no longer the case. When these layers are finalized, the number of people that can benefit from vispy will significantly increase.\r\n\r\nWe will give a brief overview of the Vispy package, and focus on the higher level modules that will make it easy to visualize images, lines, etc., and organize these object in a scene graph. Of course we will demonstrate this with several examples.\r\n\r\nWe will also talk about our progress in other areas, such as a browser backend and integration with the IPython notebook. \r\n\r\n<http://vispy.org/>", "quality_notes": "", "copyright_text": "youtube", "embed": "<iframe type='text/html' src='http://www.youtube.com/embed/D7w8H4wmPRo' width='640' height='360' frameborder='0' allowfullscreen='true'/>", "thumbnail_url": "https://i.ytimg.com/vi/D7w8H4wmPRo/hqdefault.jpg", "duration": null, "video_ogv_length": null, "video_ogv_url": "", "video_ogv_download_only": false, "video_mp4_length": null, "video_mp4_url": "", "video_mp4_download_only": false, "video_webm_length": null, "video_webm_url": "", "video_webm_download_only": false, "video_flv_length": null, "video_flv_url": "", "video_flv_download_only": false, "source_url": "https://www.youtube.com/watch?v=D7w8H4wmPRo", "whiteboard": "", "recorded": "2014-10-22", "added": "2014-11-05T22:41:03.666", "updated": "2014-11-05T22:41:03.666"}, {"category": "EuroScipy 2014", "language": "English", "slug": "ipython-protocol-kernals-and-new-features", "speakers": ["Matthias Bussionnier", "Thomas Kluyver"], "tags": [], "related_urls": [], "id": 3338, "state": 1, "title": "IPython Protocol, Kernals and new features", "summary": "", "description": "A key idea behind IPython is decoupling code execution from user interfaces. IPython relies on a documented protocol, which can be implemented by different frontends and different kernels. By implementing it, frontends and kernels gain the ability to communicate regardless of which language they're written in. The IPython project maintains three different frontends, while there are multiple third party frontends and kernels already in use.\r\n\r\nWe will show some important features that such a protocol permits, by demonstrating some of our alternative frontends, as well as kernels that people have written in languages such as Julia and R. Our presentation will also feature interactive widgets, a new feature in IPython 2.0, and preview the upcoming features that will allow a single notebook server to start different types of kernel.\r\n\r\nThis will demonstrate that the IPython Notebook is the perfect polyglot tool for scientific computation workflows.", "quality_notes": "", "copyright_text": "youtube", "embed": "<iframe type='text/html' src='http://www.youtube.com/embed/brgMEWT1pYc' width='640' height='360' frameborder='0' allowfullscreen='true'/>", "thumbnail_url": "https://i.ytimg.com/vi/brgMEWT1pYc/hqdefault.jpg", "duration": null, "video_ogv_length": null, "video_ogv_url": "", "video_ogv_download_only": false, "video_mp4_length": null, "video_mp4_url": "", "video_mp4_download_only": false, "video_webm_length": null, "video_webm_url": "", "video_webm_download_only": false, "video_flv_length": null, "video_flv_url": "", "video_flv_download_only": false, "source_url": "https://www.youtube.com/watch?v=brgMEWT1pYc", "whiteboard": "", "recorded": "2014-10-22", "added": "2014-11-05T22:41:05.087", "updated": "2014-11-05T22:41:05.087"}, {"category": "EuroScipy 2014", "language": "English", "slug": "keynote-crossing-language-barriers-with-julia-s", "speakers": ["Stephen G. Johnson"], "tags": [], "related_urls": [], "id": 3340, "state": 1, "title": "Keynote: Crossing Language Barriers with Julia, SciPy, IPython", "summary": "", "description": "Julia (julialang.org) is a new language targeted at scientific computing, which combines the high-level abstractions and dynamic interactivity of languages like Python with the performance of low-level languages like C, thanks to being designed from the beginning for efficient just-in-time compilation by LLVM. But a major challenge for any young programming language is the availability of a large ecosystem of mature libraries and tools. To overcome this difficulty, Julia is \"bootstrapping\" off of the Python ecosystem, both by making it easy to call Python code and also by exploiting infrastructure such as IPython/Jupyter.\r\n\r\nThis talk will begin with an introduction to the Julia language, both explaining why it is able to attain C-like performance in many cases. At the same time, Julia supports a number of unusual programming features, such as multiple dispatch (a kind of generalization of object-oriented programming) and metaprogramming. We will also describe how Julia connects with Python via the PyCall library, which enables straightforward, low-overhead calls to Python libraries, copy-free sharing of NumPy arrays and other large data structures, and even sharing higher-order callback functions. This gives Julia direct access to SciPy and numerous other Python packages, such as SymPy and Matplotlib. Another key component of the Python universe is IPython, and we will explain how connecting to the IPython \"Jupyter\" front-end from an IJulia back-end allows Julia to benefit from IPython's rich multimedia notebook interface, and how Julia can even use IPython 2's interactive-widget infrastructure to provide truly interactive computations.\r\n\r\nAlthough most Julia\u2013Python interaction is from Julia users calling Python, there is potential for benefits to flow in both directions in the future. The same PyCall software that allows Julia code to call Python can also allow Python code to call Julia, with the same data-sharing and rich interactivity. And Julia code can also be compiled to C-compatible interfaces\u2014currently, this is mainly used to pass Julia callback routines to C library functions (including libpython), but in the future the same facility should allow the generation of C-callable libraries written in Julia.\r\n\r\nThe presentation material and IJulia notebooks for this keynote can be found at: <https://github.com/stevengj/Julia-EuroSciPy14>", "quality_notes": "", "copyright_text": "youtube", "embed": "<iframe type='text/html' src='http://www.youtube.com/embed/jhlVHoeB05A' width='640' height='360' frameborder='0' allowfullscreen='true'/>", "thumbnail_url": "https://i.ytimg.com/vi/jhlVHoeB05A/hqdefault.jpg", "duration": null, "video_ogv_length": null, "video_ogv_url": "", "video_ogv_download_only": false, "video_mp4_length": null, "video_mp4_url": "", "video_mp4_download_only": false, "video_webm_length": null, "video_webm_url": "", "video_webm_download_only": false, "video_flv_length": null, "video_flv_url": "", "video_flv_download_only": false, "source_url": "https://www.youtube.com/watch?v=jhlVHoeB05A", "whiteboard": "", "recorded": "2014-10-22", "added": "2014-11-05T22:41:05.295", "updated": "2014-11-05T22:41:05.295"}, {"category": "EuroScipy 2014", "language": "English", "slug": "keynote-python-programming-in-science-education", "speakers": ["Ben Nuttall"], "tags": [], "related_urls": [], "id": 3339, "state": 1, "title": "Keynote: Python Programming in Science Education", "summary": "", "description": "", "quality_notes": "", "copyright_text": "youtube", "embed": "<iframe type='text/html' src='http://www.youtube.com/embed/c8Qor1WD2kE' width='640' height='360' frameborder='0' allowfullscreen='true'/>", "thumbnail_url": "https://i.ytimg.com/vi/c8Qor1WD2kE/hqdefault.jpg", "duration": null, "video_ogv_length": null, "video_ogv_url": "", "video_ogv_download_only": false, "video_mp4_length": null, "video_mp4_url": "", "video_mp4_download_only": false, "video_webm_length": null, "video_webm_url": "", "video_webm_download_only": false, "video_flv_length": null, "video_flv_url": "", "video_flv_download_only": false, "source_url": "https://www.youtube.com/watch?v=c8Qor1WD2kE", "whiteboard": "", "recorded": "2014-10-22", "added": "2014-11-05T22:41:05.199", "updated": "2014-11-05T22:41:05.199"}, {"category": "EuroScipy 2014", "language": "English", "slug": "lightning-talks-14", "speakers": [], "tags": [], "related_urls": [], "id": 3335, "state": 1, "title": "Lightning talks", "summary": "", "description": "", "quality_notes": "", "copyright_text": "youtube", "embed": "<iframe type='text/html' src='http://www.youtube.com/embed/VZ7enVMNB84' width='640' height='360' frameborder='0' allowfullscreen='true'/>", "thumbnail_url": "https://i.ytimg.com/vi/VZ7enVMNB84/hqdefault.jpg", "duration": null, "video_ogv_length": null, "video_ogv_url": "", "video_ogv_download_only": false, "video_mp4_length": null, "video_mp4_url": "", "video_mp4_download_only": false, "video_webm_length": null, "video_webm_url": "", "video_webm_download_only": false, "video_flv_length": null, "video_flv_url": "", "video_flv_download_only": false, "source_url": "https://www.youtube.com/watch?v=VZ7enVMNB84", "whiteboard": "", "recorded": "2014-10-22", "added": "2014-11-05T22:41:04.750", "updated": "2014-11-05T22:41:04.750"}, {"category": "EuroScipy 2014", "language": "English", "slug": "neural-networks-for-computer-vision", "speakers": ["Kyle Kastner"], "tags": [], "related_urls": [], "id": 3323, "state": 1, "title": "Neural Networks for Computer Vision", "summary": "", "description": "Neural networks with many layers are known as \"deep\" neural networks. While the phrase \"deep learning\" to describe deep neural networks is new, the ideas behind these networks have been around for many years. Deep neural networks attempt to learn concise, hierarchical representations of complex data, and recent advances in research have made it much easier to use these networks on many tasks, including computer vision. Due to massive increases in compute power, available data, and algorithmic techniques, neural networks have greatly improved the state of the art for many aspects of computer vision including object recognition and localization.\r\n\r\nTwo key Python packages (pylearn2 and theano) enable machine learning researchers easily develop new architectures and algorithms for neural networks which utilize GPU processing. This specialized hardware improves the computational feasibility of big neural networks, and GPU programming was a key driver (along with the development of a technique called dropout) in the resurgence of neural networks for machine learning tasks.\r\n\r\nUtilizing networks trained on extremely large compute farms as \"black-box\" preprocessing, a consumer grade desktop or laptop can approach state of the art results using standard machine learning techniques such as logistic regression and support vector machines (SVM). This idea has serious potential in the embedded/FPGA/ASIC space as well.\r\n\r\nThe python interface to pylearn2 will be heavily discussed, while also using the preprocessing features of scikit-learn for data preparation. There will also be discussion of the recent advances for pre-trained neural networks as preprocessing.\r\n\r\nAt the end of this talk, I hope you will understand what \"deep learning\" really means, how to apply these techniques to image data using Python, and how these techniques will shape the future of machine learning research and its applications.", "quality_notes": "", "copyright_text": "youtube", "embed": "<iframe type='text/html' src='http://www.youtube.com/embed/2O3vCltvicM' width='640' height='360' frameborder='0' allowfullscreen='true'/>", "thumbnail_url": "https://i.ytimg.com/vi/2O3vCltvicM/hqdefault.jpg", "duration": null, "video_ogv_length": null, "video_ogv_url": "", "video_ogv_download_only": false, "video_mp4_length": null, "video_mp4_url": "", "video_mp4_download_only": false, "video_webm_length": null, "video_webm_url": "", "video_webm_download_only": false, "video_flv_length": null, "video_flv_url": "", "video_flv_download_only": false, "source_url": "https://www.youtube.com/watch?v=2O3vCltvicM", "whiteboard": "", "recorded": "2014-10-22", "added": "2014-11-05T22:41:02.758", "updated": "2014-11-05T22:41:02.758"}, {"category": "EuroScipy 2014", "language": "English", "slug": "plotly-collaborative-python-and-matplotlib-plotti", "speakers": ["Matthew Sundquist"], "tags": [], "related_urls": [], "id": 3328, "state": 1, "title": "Plotly Collaborative Python and Matplotlib Plotting", "summary": "Plotly's Python API and sandbox let you make and share beautiful, web-based plots. This talk will be a walk-through of Plotly's library. We will craft and embed interactive graphs within an IPython Notebook from our gallery, use Plotly's GUI to edit and share graphs, and use Plotly's matplotlib wrapper to create web-based graphs and data files from matplotlib scripts. ", "description": "## Plotly: GitHub for Data and Graphs\r\n\r\n[Plotly](https://plot.ly/) is an online plotting platform. Think of it like GitHub, but for sharing data, graphs, and scripts for plotting. Plotly has a GUI and APIs for making graphs with Python, R, MATLAB, Perl, Julia, Arduino, Ruby, Raspberry Pi, and REST. The APIs let users make and share web-based graphs and interface a desktop environment with Plotly. Public sharing is free, users own their data, and users control whether data and graphs are public or private. Plotly also always pairs data and graphs, and lets you import by uploading or [live-streaming](https://github.com/plotly/Streaming-Demos).\r\n\r\n## What We'll Build\r\n\r\nPlotly allows users to make graphs with the GUI, Python, or other programming languages. We will make a number of beautiful graphs. We will make graphs with Python, share a graph, and then edit with the GUI or another programming language of choice. We will also uses Plotly's [matplotlib wrapper](http://nbviewer.ipython.org/github/plotly/IPython-plotly/blob/master/See%20more/Plotly%20and%20mpld3.ipynb) to make web-based Plotly graphs from matplotlib figures.\r\n\r\nWe will add data to a pre-existing graph, making a new version and always reverting back to previous versions. We will make a graph and store scripts, data sets, graphs, and past versions of files in Plotly.\r\n\r\nAuthors, and journalists from the and Wired Science use these Plotly features and the capacity to embed graphs in an iframe. We will conclude by showing how to optimize your embedding.\r\n\r\nMore examples can be found at <https://plot.ly/python/>.", "quality_notes": "", "copyright_text": "youtube", "embed": "<iframe type='text/html' src='http://www.youtube.com/embed/DObmPAtuNw0' width='640' height='360' frameborder='0' allowfullscreen='true'/>", "thumbnail_url": "https://i.ytimg.com/vi/DObmPAtuNw0/hqdefault.jpg", "duration": null, "video_ogv_length": null, "video_ogv_url": "", "video_ogv_download_only": false, "video_mp4_length": null, "video_mp4_url": "", "video_mp4_download_only": false, "video_webm_length": null, "video_webm_url": "", "video_webm_download_only": false, "video_flv_length": null, "video_flv_url": "", "video_flv_download_only": false, "source_url": "https://www.youtube.com/watch?v=DObmPAtuNw0", "whiteboard": "", "recorded": "2014-10-22", "added": "2014-11-05T22:41:03.859", "updated": "2014-11-05T22:41:03.859"}, {"category": "EuroScipy 2014", "language": "English", "slug": "pyfai-a-python-library-for-high-performance-azim", "speakers": ["Giannis Ashiotis", "Jerome Kieffer"], "tags": [], "related_urls": [], "id": 3332, "state": 1, "title": "PyFAI: a Python library for high performance azimuthal integration on GPU", "summary": "", "description": "In the field of X-Ray diffraction, 2D area detectors like ccd or pixel detectors have become popular in the last 15 years for diffraction experiments thanks to the large solid-angle coverage and to their better signal linearity. These detectors have a large sensitive area of millions of pixels with high spatial resolution and are getting fast: one kilo-Hertz is expected this year. The software package pyFAI we present here has been designed to reduce X-ray 2D-diffraction images into 1D curves (azimuthal integration) usable by other software for in-depth analysis such as Rietveld refinement, ... Other averaging patterns like 2D integration, image distortion, ... are also available. PyFAI is a library featuring a clean pythonic interface and aiming at being integrated into other software. But it also needs to cope with the data deluge coming from the detector...\r\n\r\nIn this contribution, we would like to highlight the performance reached by this library. To get today\u2019s computers best performances, one needs to have parallelized code and azimuthal integration is not directly parallelizable. After a scatter-to-gather transformation of the algorithm, it got parallel (Cython implementation). Other optimizations have been used to get the best performances out of GPU (compensated summation, partial parallel reductions, ...). ", "quality_notes": "", "copyright_text": "youtube", "embed": "<iframe type='text/html' src='http://www.youtube.com/embed/QSlo_Nyzeig' width='640' height='360' frameborder='0' allowfullscreen='true'/>", "thumbnail_url": "https://i.ytimg.com/vi/QSlo_Nyzeig/hqdefault.jpg", "duration": null, "video_ogv_length": null, "video_ogv_url": "", "video_ogv_download_only": false, "video_mp4_length": null, "video_mp4_url": "", "video_mp4_download_only": false, "video_webm_length": null, "video_webm_url": "", "video_webm_download_only": false, "video_flv_length": null, "video_flv_url": "", "video_flv_download_only": false, "source_url": "https://www.youtube.com/watch?v=QSlo_Nyzeig", "whiteboard": "", "recorded": "2014-10-22", "added": "2014-11-05T22:41:04.279", "updated": "2014-11-05T22:47:28.886"}]}