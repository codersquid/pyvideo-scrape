{"count": 3439, "next": "http://pyvideo.org/api/v2/video/?page=77&format=json", "previous": "http://pyvideo.org/api/v2/video/?page=75&format=json", "results": [{"category": "SciPy 2014", "language": "English", "slug": "hdf5-is-for-lovers-tutorial-part-1", "speakers": ["Anthony Scopatz"], "tags": ["HDF5", "PyTables", "tutorial"], "related_urls": [], "id": 2705, "state": 1, "title": "HDF5 is for Lovers, Tutorial part 1", "summary": "HDF5 is a hierarchical, binary database format that has become the de facto standard for \r\nscientific computing. While the spec may be used in a relatively simple way it also supports several high-level features that prove invaluable. HDF5 bindings exist for almost every language - including two Python libraries (PyTables and h5py). This tutorial will cover HDF5 through the lens of PyTables.", "description": "Description\r\n------------\r\nHDF5 is a hierarchical, binary database format that has become the de facto standard for \r\nscientific computing.  While the specification may be used in a relatively simple way \r\n(persistence of static arrays) it also supports several high-level features that prove \r\ninvaluable.  These include chunking, ragged data, extensible data, parallel I/O, \r\ncompression, complex selection, and in-core calculations.  Moreover, HDF5 bindings\r\nexist for almost every language - including two Python libraries (PyTables and h5py). This tutorial will cover HDF5 itself through the lens of PyTables.\r\n\r\nThis tutorial will discuss tools, strategies, and hacks for really squeezing every ounce\r\nof performance out of HDF5 in new or existing projects.  It will also go over fundamental \r\nlimitations in the specification and provide creative and subtle strategies for getting around \r\nthem.  Overall, this tutorial will show how HDF5 plays nicely with all parts of an application \r\nmaking the code and data both faster and smaller.  With such powerful features at the \r\ndeveloper's disposal, what is not to love?!\r\n\r\nKnowledge of Python, NumPy, C or C++, and basic HDF5 is recommended but not required.\r\n\r\nOutline\r\n--------------\r\n* Meaning in layout (20 min)\r\n\r\n    - Tips for choosing your hierarchy\r\n\r\n* Advanced datatypes (20 min)\r\n\r\n    - Tables\r\n    - Nested types\r\n    - Tricks with malloc() and byte-counting\r\n\r\n* **Exercise on above topics** (20 min)\r\n\r\n* Chunking (20 min)\r\n\r\n    - How it works\r\n    - How to properly select your chunksize\r\n\r\n* Queries and Selections (20 min)\r\n\r\n    - In-core vs Out-of-core calculations\r\n    - PyTables.where()\r\n    - Datasets vs Dataspaces\r\n\r\n* **Exercise on above topics** (20 min)\r\n\r\n* The Starving CPU Problem (1 hr)\r\n\r\n    - Why you should always use compression\r\n    - Compression algorithms available\r\n    - Choosing the correct one\r\n    - Exercise\r\n\r\n* Integration with other databases (1 hr)\r\n\r\n    - Migrating to/from SQL\r\n    - HDF5 in other databases (JSON example)\r\n    - Other Databases in HDF5 (JSON example)\r\n    - Exercise\r\n", "quality_notes": "", "copyright_text": "http://www.youtube.com/t/terms", "embed": "<object width=\"640\" height=\"390\"><param name=\"movie\" value=\"http://youtube.com/v/EoqGt32gkPc?version=3&amp;hl=en_US\"></param><param name=\"allowFullScreen\" value=\"true\"></param><param name=\"allowscriptaccess\" value=\"always\"></param><embed src=\"http://youtube.com/v/EoqGt32gkPc?version=3&amp;hl=en_US\" type=\"application/x-shockwave-flash\" width=\"640\" height=\"390\" allowscriptaccess=\"always\" allowfullscreen=\"true\"></embed></object>", "thumbnail_url": "http://i1.ytimg.com/vi/EoqGt32gkPc/hqdefault.jpg", "duration": null, "video_ogv_length": null, "video_ogv_url": "", "video_ogv_download_only": false, "video_mp4_length": null, "video_mp4_url": "", "video_mp4_download_only": false, "video_webm_length": null, "video_webm_url": "", "video_webm_download_only": false, "video_flv_length": null, "video_flv_url": "", "video_flv_download_only": false, "source_url": "http://www.youtube.com/watch?v=EoqGt32gkPc", "whiteboard": "", "recorded": "2014-07-09", "added": "2014-07-09T19:24:45.472", "updated": "2014-07-09T19:24:45.472"}, {"category": "SciPy 2014", "language": "English", "slug": "image-analysis-in-python-with-scipy-and-scikit-im", "speakers": ["Juan Nunez-Iglesias", "Tony Yu"], "tags": ["scikit"], "related_urls": [], "id": 2752, "state": 1, "title": "Image analysis in Python with scipy and scikit image 4", "summary": "From telescopes to satellite cameras to electron microscopes, scientists are producing more images than they can manually inspect. This tutorial will introduce automated image analysis using the \"images as numpy arrays\" abstraction, run through various fundamental image analysis operations (filters, morphology, segmentation), and finally complete one or two more advanced real-world examples.", "description": "Image analysis is central to a boggling number of scientific endeavors. Google needs it for their self-driving cars and to match satellite imagery and mapping data. Neuroscientists need it to understand the brain. NASA needs it to [map asteroids](http://www.bbc.co.uk/news/technology-26528516) and save the human race. It is, however, a relatively underdeveloped area of scientific computing. Attendees will leave this tutorial confident of their ability to extract information from their images in Python.\r\n\r\nAttendees will need a working knowledge of numpy arrays, but no further knowledge of images or voxels or other doodads. After a brief introduction to the idea that images are just arrays and vice versa, we will introduce fundamental image analysis operations: filters, which can be used to extract features such as edges, corners, and spots in an image; morphology, inferring shape properties by modifying the image through local operations; and segmentation, the division of an image into meaningful regions.\r\n\r\nWe will then combine all these concepts and apply them to several real-world examples of scientific image analysis:\r\ngiven an image of a pothole, measure its size in pixels\r\ncompare the fluorescence intensity of a protein of interest in the centromeres vs the rest of the chromosome.\r\nobserve the distribution of cells invading a wound site\r\n\r\nAttendees will also be encouraged to bring their own image analysis problems to the session for guidance, and, if time allows, we will cover more advanced topics such as image registration and stitching.\r\n\r\nThe entire tutorial will be coordinated with the IPython notebook, with various code cells left blank for attendees to fill in as exercises.", "quality_notes": "", "copyright_text": "http://www.youtube.com/t/terms", "embed": "<object width=\"640\" height=\"390\"><param name=\"movie\" value=\"http://youtube.com/v/pWnYjqudKHs?version=3&amp;hl=en_US\"></param><param name=\"allowFullScreen\" value=\"true\"></param><param name=\"allowscriptaccess\" value=\"always\"></param><embed src=\"http://youtube.com/v/pWnYjqudKHs?version=3&amp;hl=en_US\" type=\"application/x-shockwave-flash\" width=\"640\" height=\"390\" allowscriptaccess=\"always\" allowfullscreen=\"true\"></embed></object>", "thumbnail_url": "http://i1.ytimg.com/vi/pWnYjqudKHs/hqdefault.jpg", "duration": null, "video_ogv_length": null, "video_ogv_url": null, "video_ogv_download_only": false, "video_mp4_length": null, "video_mp4_url": null, "video_mp4_download_only": false, "video_webm_length": null, "video_webm_url": null, "video_webm_download_only": false, "video_flv_length": null, "video_flv_url": null, "video_flv_download_only": false, "source_url": "http://www.youtube.com/watch?v=pWnYjqudKHs", "whiteboard": "", "recorded": "2014-07-09", "added": "2014-07-10T22:35:20.238", "updated": "2014-07-10T22:35:20.238"}, {"category": "SciPy 2014", "language": "English", "slug": "image-analysis-with-scikit-image-part-1", "speakers": ["Juan Nunez-Iglesias", "Tony Yu"], "tags": ["scikit"], "related_urls": [], "id": 2863, "state": 1, "title": "Image analysis in Python with scipy and scikit image, Part 1", "summary": "From telescopes to satellite cameras to electron microscopes, scientists are producing more images than they can manually inspect. This tutorial will introduce automated image analysis using the \"images as numpy arrays\" abstraction, run through various fundamental image analysis operations (filters, morphology, segmentation), and finally complete one or two more advanced real-world examples.", "description": "Image analysis is central to a boggling number of scientific endeavors. Google needs it for their self-driving cars and to match satellite imagery and mapping data. Neuroscientists need it to understand the brain. NASA needs it to [map asteroids](http://www.bbc.co.uk/news/technology-26528516) and save the human race. It is, however, a relatively underdeveloped area of scientific computing. Attendees will leave this tutorial confident of their ability to extract information from their images in Python.\r\n\r\nAttendees will need a working knowledge of numpy arrays, but no further knowledge of images or voxels or other doodads. After a brief introduction to the idea that images are just arrays and vice versa, we will introduce fundamental image analysis operations: filters, which can be used to extract features such as edges, corners, and spots in an image; morphology, inferring shape properties by modifying the image through local operations; and segmentation, the division of an image into meaningful regions.\r\n\r\nWe will then combine all these concepts and apply them to several real-world examples of scientific image analysis:\r\ngiven an image of a pothole, measure its size in pixels\r\ncompare the fluorescence intensity of a protein of interest in the centromeres vs the rest of the chromosome.\r\nobserve the distribution of cells invading a wound site\r\n\r\nAttendees will also be encouraged to bring their own image analysis problems to the session for guidance, and, if time allows, we will cover more advanced topics such as image registration and stitching.\r\n\r\nThe entire tutorial will be coordinated with the IPython notebook, with various code cells left blank for attendees to fill in as exercises.", "quality_notes": "", "copyright_text": "http://www.youtube.com/t/terms", "embed": "<object width=\"640\" height=\"390\"><param name=\"movie\" value=\"http://youtube.com/v/MP-MTiCETYg?version=3&amp;hl=en_US\"></param><param name=\"allowFullScreen\" value=\"true\"></param><param name=\"allowscriptaccess\" value=\"always\"></param><embed src=\"http://youtube.com/v/MP-MTiCETYg?version=3&amp;hl=en_US\" type=\"application/x-shockwave-flash\" width=\"640\" height=\"390\" allowscriptaccess=\"always\" allowfullscreen=\"true\"></embed></object>", "thumbnail_url": "http://i1.ytimg.com/vi/MP-MTiCETYg/hqdefault.jpg", "duration": null, "video_ogv_length": null, "video_ogv_url": "", "video_ogv_download_only": false, "video_mp4_length": null, "video_mp4_url": "", "video_mp4_download_only": false, "video_webm_length": null, "video_webm_url": "", "video_webm_download_only": false, "video_flv_length": null, "video_flv_url": "", "video_flv_download_only": false, "source_url": "http://www.youtube.com/watch?v=MP-MTiCETYg", "whiteboard": "", "recorded": "2014-07-09", "added": "2014-07-19T22:16:55.377", "updated": "2014-07-19T22:19:53.623"}, {"category": "SciPy 2014", "language": "English", "slug": "image-analysis-with-scikit-image-part-2", "speakers": ["Juan Nunez-Iglesias", "Tony Yu"], "tags": ["scikit"], "related_urls": [], "id": 2862, "state": 1, "title": "Image analysis in Python with scipy and scikit image, Part 2", "summary": "From telescopes to satellite cameras to electron microscopes, scientists are producing more images than they can manually inspect. This tutorial will introduce automated image analysis using the \"images as numpy arrays\" abstraction, run through various fundamental image analysis operations (filters, morphology, segmentation), and finally complete one or two more advanced real-world examples.", "description": "Image analysis is central to a boggling number of scientific endeavors. Google needs it for their self-driving cars and to match satellite imagery and mapping data. Neuroscientists need it to understand the brain. NASA needs it to [map asteroids](http://www.bbc.co.uk/news/technology-26528516) and save the human race. It is, however, a relatively underdeveloped area of scientific computing. Attendees will leave this tutorial confident of their ability to extract information from their images in Python.\r\n\r\nAttendees will need a working knowledge of numpy arrays, but no further knowledge of images or voxels or other doodads. After a brief introduction to the idea that images are just arrays and vice versa, we will introduce fundamental image analysis operations: filters, which can be used to extract features such as edges, corners, and spots in an image; morphology, inferring shape properties by modifying the image through local operations; and segmentation, the division of an image into meaningful regions.\r\n\r\nWe will then combine all these concepts and apply them to several real-world examples of scientific image analysis:\r\ngiven an image of a pothole, measure its size in pixels\r\ncompare the fluorescence intensity of a protein of interest in the centromeres vs the rest of the chromosome.\r\nobserve the distribution of cells invading a wound site\r\n\r\nAttendees will also be encouraged to bring their own image analysis problems to the session for guidance, and, if time allows, we will cover more advanced topics such as image registration and stitching.\r\n\r\nThe entire tutorial will be coordinated with the IPython notebook, with various code cells left blank for attendees to fill in as exercises.", "quality_notes": "", "copyright_text": "http://www.youtube.com/t/terms", "embed": "<object width=\"640\" height=\"390\"><param name=\"movie\" value=\"http://youtube.com/v/SE7h0IWD93Y?version=3&amp;hl=en_US\"></param><param name=\"allowFullScreen\" value=\"true\"></param><param name=\"allowscriptaccess\" value=\"always\"></param><embed src=\"http://youtube.com/v/SE7h0IWD93Y?version=3&amp;hl=en_US\" type=\"application/x-shockwave-flash\" width=\"640\" height=\"390\" allowscriptaccess=\"always\" allowfullscreen=\"true\"></embed></object>", "thumbnail_url": "http://i1.ytimg.com/vi/SE7h0IWD93Y/hqdefault.jpg", "duration": null, "video_ogv_length": null, "video_ogv_url": "", "video_ogv_download_only": false, "video_mp4_length": null, "video_mp4_url": "", "video_mp4_download_only": false, "video_webm_length": null, "video_webm_url": "", "video_webm_download_only": false, "video_flv_length": null, "video_flv_url": "", "video_flv_download_only": false, "source_url": "http://www.youtube.com/watch?v=SE7h0IWD93Y", "whiteboard": "", "recorded": "2014-07-09", "added": "2014-07-19T22:16:55.266", "updated": "2014-07-19T22:20:31.576"}, {"category": "SciPy 2014", "language": "English", "slug": "image-analysis-with-scikit-image-part-3", "speakers": ["Juan Nunez-Iglesias", "Tony Yu"], "tags": ["scikit"], "related_urls": [], "id": 2861, "state": 1, "title": "Image analysis in Python with scipy and scikit image, Part 3", "summary": "From telescopes to satellite cameras to electron microscopes, scientists are producing more images than they can manually inspect. This tutorial will introduce automated image analysis using the \"images as numpy arrays\" abstraction, run through various fundamental image analysis operations (filters, morphology, segmentation), and finally complete one or two more advanced real-world examples.", "description": "Image analysis is central to a boggling number of scientific endeavors. Google needs it for their self-driving cars and to match satellite imagery and mapping data. Neuroscientists need it to understand the brain. NASA needs it to [map asteroids](http://www.bbc.co.uk/news/technology-26528516) and save the human race. It is, however, a relatively underdeveloped area of scientific computing. Attendees will leave this tutorial confident of their ability to extract information from their images in Python.\r\n\r\nAttendees will need a working knowledge of numpy arrays, but no further knowledge of images or voxels or other doodads. After a brief introduction to the idea that images are just arrays and vice versa, we will introduce fundamental image analysis operations: filters, which can be used to extract features such as edges, corners, and spots in an image; morphology, inferring shape properties by modifying the image through local operations; and segmentation, the division of an image into meaningful regions.\r\n\r\nWe will then combine all these concepts and apply them to several real-world examples of scientific image analysis:\r\ngiven an image of a pothole, measure its size in pixels\r\ncompare the fluorescence intensity of a protein of interest in the centromeres vs the rest of the chromosome.\r\nobserve the distribution of cells invading a wound site\r\n\r\nAttendees will also be encouraged to bring their own image analysis problems to the session for guidance, and, if time allows, we will cover more advanced topics such as image registration and stitching.\r\n\r\nThe entire tutorial will be coordinated with the IPython notebook, with various code cells left blank for attendees to fill in as exercises.", "quality_notes": "", "copyright_text": "http://www.youtube.com/t/terms", "embed": "<object width=\"640\" height=\"390\"><param name=\"movie\" value=\"http://youtube.com/v/Yxpnvc4RHy4?version=3&amp;hl=en_US\"></param><param name=\"allowFullScreen\" value=\"true\"></param><param name=\"allowscriptaccess\" value=\"always\"></param><embed src=\"http://youtube.com/v/Yxpnvc4RHy4?version=3&amp;hl=en_US\" type=\"application/x-shockwave-flash\" width=\"640\" height=\"390\" allowscriptaccess=\"always\" allowfullscreen=\"true\"></embed></object>", "thumbnail_url": "http://i1.ytimg.com/vi/Yxpnvc4RHy4/hqdefault.jpg", "duration": null, "video_ogv_length": null, "video_ogv_url": "", "video_ogv_download_only": false, "video_mp4_length": null, "video_mp4_url": "", "video_mp4_download_only": false, "video_webm_length": null, "video_webm_url": "", "video_webm_download_only": false, "video_flv_length": null, "video_flv_url": "", "video_flv_download_only": false, "source_url": "http://www.youtube.com/watch?v=Yxpnvc4RHy4", "whiteboard": "", "recorded": "2014-07-09", "added": "2014-07-19T22:16:55.159", "updated": "2014-07-19T22:20:58.605"}, {"category": "SciPy 2014", "language": "English", "slug": "integrating-python-and-c-with-boost-python-part-0", "speakers": ["Austin Bingham"], "tags": ["boost", "c++"], "related_urls": [], "id": 2749, "state": 1, "title": "Integrating Python and C++ with Boost Python part 1", "summary": "Python and C++ can be powerful complements to one another. C++ is great for performance-critical calculations, while Python is great for everything else. In this tutorial we\u2019ll look at how to integrate Python and C++ using the Boost.Python library. You\u2019ll learn techniques for easily developing hybrid systems that use the right language for the right task, resulting in better software.\r\n", "description": "Python and C++ are both popular languages that each bring a lot to the table. The languages also complement one another well: Python is high-level, dynamic, and easy to use while C++ is at-the-metal, static, and (in)famously tricky. There are times when there are real advantages to combining these disparate natures, and Python\u2019s C API provides a strong interface for doing just that. Boost.Python is a C++ library that builds upon and improves Python\u2019s C API to give users a simpler, more intuitive, and safer means to integrate Python and C++.\r\n\r\nIn this tutorial we\u2019ll look at how to use Boost.Python to effectively bridge the Python/C++ boundary. We\u2019ll start by briefly looking at the fundamentals of the Python C API since that defines the \u201cground rules\u201d; this includes things like reference counting, the basic object model, and so forth. We\u2019ll then quickly look at the Boost.Python API and show how it provides the same functionality as the underlying C API, but does so in a way that doesn\u2019t obscure the real semantics of the Python language.\r\n\r\nAfter this introduction, the rest of the tutorial will involve writing code to explore various elements of Boost.Python. We\u2019ll focus on techniques for extending Python with C++, that is, writing Python modules in C++. Boost.Python can be used for embedding (i.e. invoking Python code from C++), but that involves a different set of techniques, and in practice most scientific Python developers are more interested in developing extensions.\r\n\r\nThe syllabus for the four-hour tutorial will be like this:\r\n\r\n1. Introduction: C-API and Boost.Python basics\r\n\r\n    Note that this can be reduced or eliminated of participants are already comfortable with the topics.\r\n\r\n2. Hello World: Exposing a basic function\r\n\r\n    In this section we\u2019ll get a minimal Boost.Python module working. This will not only introduce students to the infrastructure of Boost.Python, but it will also give us a chance to make sure that everyone\u2019s build environment is working.\r\n\r\n3. Exposing functions\r\n\r\n    In this section we\u2019ll look at the details of exposing C++ functions to Python. The topics we\u2019ll cover will include overloading (including Boost.Python\u2019s auto-overload feature), default argument values, and a brief look at call policies.\r\n\r\n4. Exposing classes\r\n\r\n    Here we\u2019ll look at how to expose C++ classes to Python. Topics will include the basic `class_<T>` template, member functions, data members, properties, inheritance, and virtual functions.\r\n\r\n5. `boost::python::object`\r\n\r\n    The `boost::python::object` class is Boost.Python\u2019s primary interface to Python\u2019s `PyObject` structure. Understanding how to work with this class is a key building-block for developing Python modules with Boost.Python. We\u2019ll explore its API and features, including areas like attribute access, reference counting, and converting between Python and C++ objects.\r\n\r\n6. Derived object types\r\n\r\n    Boost.Python provides a number of `boost::python::object` subclasses for important Python classes like `list`, `dict`, and `tuple`. In this section we\u2019ll look at these subclasses and how to use them in Boost.Python modules.\r\n\r\n7. Enums\r\n\r\n    Boost.Python provides `enum_<T>` for exposing C++ enums to Python. Python doesn\u2019t have a notion of enums *per se*, but in this section we\u2019ll explore how this template makes it straightforward to use C++ enums in Python in a simple and intuitive way.\r\n\r\n8. Type conversion\r\n\r\n    In this section we\u2019ll look at Boost.Python\u2019s support for doing automatic type-conversion across the Python/C++ boundary. We\u2019ll see how you can register type-converters with Boost.Python which will be invoked whenever Boost.Python needs to convert a Python object to a C++ object or vice versa.\r\n\r\nThis is a fairly ambitious set of topics, and it\u2019s possible that we won\u2019t be able to cover them all. The topics are roughly in most-often-used to least-often-used order, however, so students will be sure to be exposed to the most important and relevant elements of the course.\r\n\r\nLikewise, the four-hour format of the course means that we won\u2019t be able to go into great depth on many topics. The main goal of the course, then, is to give students enough orientation and hands-on experience with Boost.Python that they can continue to learn on their own. Inter-language integration - especially between languages as dissimilar as C++ and Python - can be quite complex, but this tutorial will give students the grounding they need to successfully apply Boost.Python to their problems.  \r\n", "quality_notes": "", "copyright_text": "http://www.youtube.com/t/terms", "embed": "<object width=\"640\" height=\"390\"><param name=\"movie\" value=\"http://youtube.com/v/GE8EsGUsC2w?version=3&amp;hl=en_US\"></param><param name=\"allowFullScreen\" value=\"true\"></param><param name=\"allowscriptaccess\" value=\"always\"></param><embed src=\"http://youtube.com/v/GE8EsGUsC2w?version=3&amp;hl=en_US\" type=\"application/x-shockwave-flash\" width=\"640\" height=\"390\" allowscriptaccess=\"always\" allowfullscreen=\"true\"></embed></object>", "thumbnail_url": "http://i1.ytimg.com/vi/GE8EsGUsC2w/hqdefault.jpg", "duration": null, "video_ogv_length": null, "video_ogv_url": null, "video_ogv_download_only": false, "video_mp4_length": null, "video_mp4_url": null, "video_mp4_download_only": false, "video_webm_length": null, "video_webm_url": null, "video_webm_download_only": false, "video_flv_length": null, "video_flv_url": null, "video_flv_download_only": false, "source_url": "http://www.youtube.com/watch?v=GE8EsGUsC2w", "whiteboard": "", "recorded": "2014-07-09", "added": "2014-07-10T22:35:18.992", "updated": "2014-07-10T22:35:18.992"}, {"category": "SciPy 2014", "language": "English", "slug": "integrating-python-and-c-with-boost-python-part", "speakers": ["Austin Bingham"], "tags": ["boost", "c++"], "related_urls": [], "id": 2748, "state": 1, "title": "Integrating Python and C++ with Boost Python part 2", "summary": "Python and C++ can be powerful complements to one another. C++ is great for performance-critical calculations, while Python is great for everything else. In this tutorial we\u2019ll look at how to integrate Python and C++ using the Boost.Python library. You\u2019ll learn techniques for easily developing hybrid systems that use the right language for the right task, resulting in better software.\r\n", "description": "Python and C++ are both popular languages that each bring a lot to the table. The languages also complement one another well: Python is high-level, dynamic, and easy to use while C++ is at-the-metal, static, and (in)famously tricky. There are times when there are real advantages to combining these disparate natures, and Python\u2019s C API provides a strong interface for doing just that. Boost.Python is a C++ library that builds upon and improves Python\u2019s C API to give users a simpler, more intuitive, and safer means to integrate Python and C++.\r\n\r\nIn this tutorial we\u2019ll look at how to use Boost.Python to effectively bridge the Python/C++ boundary. We\u2019ll start by briefly looking at the fundamentals of the Python C API since that defines the \u201cground rules\u201d; this includes things like reference counting, the basic object model, and so forth. We\u2019ll then quickly look at the Boost.Python API and show how it provides the same functionality as the underlying C API, but does so in a way that doesn\u2019t obscure the real semantics of the Python language.\r\n\r\nAfter this introduction, the rest of the tutorial will involve writing code to explore various elements of Boost.Python. We\u2019ll focus on techniques for extending Python with C++, that is, writing Python modules in C++. Boost.Python can be used for embedding (i.e. invoking Python code from C++), but that involves a different set of techniques, and in practice most scientific Python developers are more interested in developing extensions.\r\n\r\nThe syllabus for the four-hour tutorial will be like this:\r\n\r\n1. Introduction: C-API and Boost.Python basics\r\n\r\n    Note that this can be reduced or eliminated of participants are already comfortable with the topics.\r\n\r\n2. Hello World: Exposing a basic function\r\n\r\n    In this section we\u2019ll get a minimal Boost.Python module working. This will not only introduce students to the infrastructure of Boost.Python, but it will also give us a chance to make sure that everyone\u2019s build environment is working.\r\n\r\n3. Exposing functions\r\n\r\n    In this section we\u2019ll look at the details of exposing C++ functions to Python. The topics we\u2019ll cover will include overloading (including Boost.Python\u2019s auto-overload feature), default argument values, and a brief look at call policies.\r\n\r\n4. Exposing classes\r\n\r\n    Here we\u2019ll look at how to expose C++ classes to Python. Topics will include the basic `class_<T>` template, member functions, data members, properties, inheritance, and virtual functions.\r\n\r\n5. `boost::python::object`\r\n\r\n    The `boost::python::object` class is Boost.Python\u2019s primary interface to Python\u2019s `PyObject` structure. Understanding how to work with this class is a key building-block for developing Python modules with Boost.Python. We\u2019ll explore its API and features, including areas like attribute access, reference counting, and converting between Python and C++ objects.\r\n\r\n6. Derived object types\r\n\r\n    Boost.Python provides a number of `boost::python::object` subclasses for important Python classes like `list`, `dict`, and `tuple`. In this section we\u2019ll look at these subclasses and how to use them in Boost.Python modules.\r\n\r\n7. Enums\r\n\r\n    Boost.Python provides `enum_<T>` for exposing C++ enums to Python. Python doesn\u2019t have a notion of enums *per se*, but in this section we\u2019ll explore how this template makes it straightforward to use C++ enums in Python in a simple and intuitive way.\r\n\r\n8. Type conversion\r\n\r\n    In this section we\u2019ll look at Boost.Python\u2019s support for doing automatic type-conversion across the Python/C++ boundary. We\u2019ll see how you can register type-converters with Boost.Python which will be invoked whenever Boost.Python needs to convert a Python object to a C++ object or vice versa.\r\n\r\nThis is a fairly ambitious set of topics, and it\u2019s possible that we won\u2019t be able to cover them all. The topics are roughly in most-often-used to least-often-used order, however, so students will be sure to be exposed to the most important and relevant elements of the course.\r\n\r\nLikewise, the four-hour format of the course means that we won\u2019t be able to go into great depth on many topics. The main goal of the course, then, is to give students enough orientation and hands-on experience with Boost.Python that they can continue to learn on their own. Inter-language integration - especially between languages as dissimilar as C++ and Python - can be quite complex, but this tutorial will give students the grounding they need to successfully apply Boost.Python to their problems.  \r\n", "quality_notes": "", "copyright_text": "http://www.youtube.com/t/terms", "embed": "<object width=\"640\" height=\"390\"><param name=\"movie\" value=\"http://youtube.com/v/WLKuHbkh6jU?version=3&amp;hl=en_US\"></param><param name=\"allowFullScreen\" value=\"true\"></param><param name=\"allowscriptaccess\" value=\"always\"></param><embed src=\"http://youtube.com/v/WLKuHbkh6jU?version=3&amp;hl=en_US\" type=\"application/x-shockwave-flash\" width=\"640\" height=\"390\" allowscriptaccess=\"always\" allowfullscreen=\"true\"></embed></object>", "thumbnail_url": "http://i1.ytimg.com/vi/WLKuHbkh6jU/hqdefault.jpg", "duration": null, "video_ogv_length": null, "video_ogv_url": null, "video_ogv_download_only": false, "video_mp4_length": null, "video_mp4_url": null, "video_mp4_download_only": false, "video_webm_length": null, "video_webm_url": null, "video_webm_download_only": false, "video_flv_length": null, "video_flv_url": null, "video_flv_download_only": false, "source_url": "http://www.youtube.com/watch?v=WLKuHbkh6jU", "whiteboard": "", "recorded": "2014-07-09", "added": "2014-07-10T22:35:17.239", "updated": "2014-07-10T22:35:17.239"}, {"category": "SciPy 2014", "language": "English", "slug": "integrating-python-and-c-with-boost-python-part-1", "speakers": ["Austin Bingham"], "tags": ["boost", "c++"], "related_urls": [], "id": 2750, "state": 1, "title": "Integrating Python and C++ with Boost Python part 3", "summary": "Python and C++ can be powerful complements to one another. C++ is great for performance-critical calculations, while Python is great for everything else. In this tutorial we\u2019ll look at how to integrate Python and C++ using the Boost.Python library. You\u2019ll learn techniques for easily developing hybrid systems that use the right language for the right task, resulting in better software.\r\n", "description": "Python and C++ are both popular languages that each bring a lot to the table. The languages also complement one another well: Python is high-level, dynamic, and easy to use while C++ is at-the-metal, static, and (in)famously tricky. There are times when there are real advantages to combining these disparate natures, and Python\u2019s C API provides a strong interface for doing just that. Boost.Python is a C++ library that builds upon and improves Python\u2019s C API to give users a simpler, more intuitive, and safer means to integrate Python and C++.\r\n\r\nIn this tutorial we\u2019ll look at how to use Boost.Python to effectively bridge the Python/C++ boundary. We\u2019ll start by briefly looking at the fundamentals of the Python C API since that defines the \u201cground rules\u201d; this includes things like reference counting, the basic object model, and so forth. We\u2019ll then quickly look at the Boost.Python API and show how it provides the same functionality as the underlying C API, but does so in a way that doesn\u2019t obscure the real semantics of the Python language.\r\n\r\nAfter this introduction, the rest of the tutorial will involve writing code to explore various elements of Boost.Python. We\u2019ll focus on techniques for extending Python with C++, that is, writing Python modules in C++. Boost.Python can be used for embedding (i.e. invoking Python code from C++), but that involves a different set of techniques, and in practice most scientific Python developers are more interested in developing extensions.\r\n\r\nThe syllabus for the four-hour tutorial will be like this:\r\n\r\n1. Introduction: C-API and Boost.Python basics\r\n\r\n    Note that this can be reduced or eliminated of participants are already comfortable with the topics.\r\n\r\n2. Hello World: Exposing a basic function\r\n\r\n    In this section we\u2019ll get a minimal Boost.Python module working. This will not only introduce students to the infrastructure of Boost.Python, but it will also give us a chance to make sure that everyone\u2019s build environment is working.\r\n\r\n3. Exposing functions\r\n\r\n    In this section we\u2019ll look at the details of exposing C++ functions to Python. The topics we\u2019ll cover will include overloading (including Boost.Python\u2019s auto-overload feature), default argument values, and a brief look at call policies.\r\n\r\n4. Exposing classes\r\n\r\n    Here we\u2019ll look at how to expose C++ classes to Python. Topics will include the basic `class_<T>` template, member functions, data members, properties, inheritance, and virtual functions.\r\n\r\n5. `boost::python::object`\r\n\r\n    The `boost::python::object` class is Boost.Python\u2019s primary interface to Python\u2019s `PyObject` structure. Understanding how to work with this class is a key building-block for developing Python modules with Boost.Python. We\u2019ll explore its API and features, including areas like attribute access, reference counting, and converting between Python and C++ objects.\r\n\r\n6. Derived object types\r\n\r\n    Boost.Python provides a number of `boost::python::object` subclasses for important Python classes like `list`, `dict`, and `tuple`. In this section we\u2019ll look at these subclasses and how to use them in Boost.Python modules.\r\n\r\n7. Enums\r\n\r\n    Boost.Python provides `enum_<T>` for exposing C++ enums to Python. Python doesn\u2019t have a notion of enums *per se*, but in this section we\u2019ll explore how this template makes it straightforward to use C++ enums in Python in a simple and intuitive way.\r\n\r\n8. Type conversion\r\n\r\n    In this section we\u2019ll look at Boost.Python\u2019s support for doing automatic type-conversion across the Python/C++ boundary. We\u2019ll see how you can register type-converters with Boost.Python which will be invoked whenever Boost.Python needs to convert a Python object to a C++ object or vice versa.\r\n\r\nThis is a fairly ambitious set of topics, and it\u2019s possible that we won\u2019t be able to cover them all. The topics are roughly in most-often-used to least-often-used order, however, so students will be sure to be exposed to the most important and relevant elements of the course.\r\n\r\nLikewise, the four-hour format of the course means that we won\u2019t be able to go into great depth on many topics. The main goal of the course, then, is to give students enough orientation and hands-on experience with Boost.Python that they can continue to learn on their own. Inter-language integration - especially between languages as dissimilar as C++ and Python - can be quite complex, but this tutorial will give students the grounding they need to successfully apply Boost.Python to their problems.  \r\n", "quality_notes": "", "copyright_text": "http://www.youtube.com/t/terms", "embed": "<object width=\"640\" height=\"390\"><param name=\"movie\" value=\"http://youtube.com/v/kR5tREIotlI?version=3&amp;hl=en_US\"></param><param name=\"allowFullScreen\" value=\"true\"></param><param name=\"allowscriptaccess\" value=\"always\"></param><embed src=\"http://youtube.com/v/kR5tREIotlI?version=3&amp;hl=en_US\" type=\"application/x-shockwave-flash\" width=\"640\" height=\"390\" allowscriptaccess=\"always\" allowfullscreen=\"true\"></embed></object>", "thumbnail_url": "http://i1.ytimg.com/vi/kR5tREIotlI/hqdefault.jpg", "duration": null, "video_ogv_length": null, "video_ogv_url": null, "video_ogv_download_only": false, "video_mp4_length": null, "video_mp4_url": null, "video_mp4_download_only": false, "video_webm_length": null, "video_webm_url": null, "video_webm_download_only": false, "video_flv_length": null, "video_flv_url": null, "video_flv_download_only": false, "source_url": "http://www.youtube.com/watch?v=kR5tREIotlI", "whiteboard": "", "recorded": "2014-07-09", "added": "2014-07-10T22:35:19.418", "updated": "2014-07-10T22:35:19.418"}, {"category": "SciPy 2014", "language": "English", "slug": "integrating-python-and-c-with-boost-python-part-2", "speakers": ["Austin Bingham"], "tags": ["boost", "c++"], "related_urls": [], "id": 2751, "state": 1, "title": "Integrating Python and C++ with Boost Python part 4", "summary": "Python and C++ can be powerful complements to one another. C++ is great for performance-critical calculations, while Python is great for everything else. In this tutorial we\u2019ll look at how to integrate Python and C++ using the Boost.Python library. You\u2019ll learn techniques for easily developing hybrid systems that use the right language for the right task, resulting in better software.\r\n", "description": "Python and C++ are both popular languages that each bring a lot to the table. The languages also complement one another well: Python is high-level, dynamic, and easy to use while C++ is at-the-metal, static, and (in)famously tricky. There are times when there are real advantages to combining these disparate natures, and Python\u2019s C API provides a strong interface for doing just that. Boost.Python is a C++ library that builds upon and improves Python\u2019s C API to give users a simpler, more intuitive, and safer means to integrate Python and C++.\r\n\r\nIn this tutorial we\u2019ll look at how to use Boost.Python to effectively bridge the Python/C++ boundary. We\u2019ll start by briefly looking at the fundamentals of the Python C API since that defines the \u201cground rules\u201d; this includes things like reference counting, the basic object model, and so forth. We\u2019ll then quickly look at the Boost.Python API and show how it provides the same functionality as the underlying C API, but does so in a way that doesn\u2019t obscure the real semantics of the Python language.\r\n\r\nAfter this introduction, the rest of the tutorial will involve writing code to explore various elements of Boost.Python. We\u2019ll focus on techniques for extending Python with C++, that is, writing Python modules in C++. Boost.Python can be used for embedding (i.e. invoking Python code from C++), but that involves a different set of techniques, and in practice most scientific Python developers are more interested in developing extensions.\r\n\r\nThe syllabus for the four-hour tutorial will be like this:\r\n\r\n1. Introduction: C-API and Boost.Python basics\r\n\r\n    Note that this can be reduced or eliminated of participants are already comfortable with the topics.\r\n\r\n2. Hello World: Exposing a basic function\r\n\r\n    In this section we\u2019ll get a minimal Boost.Python module working. This will not only introduce students to the infrastructure of Boost.Python, but it will also give us a chance to make sure that everyone\u2019s build environment is working.\r\n\r\n3. Exposing functions\r\n\r\n    In this section we\u2019ll look at the details of exposing C++ functions to Python. The topics we\u2019ll cover will include overloading (including Boost.Python\u2019s auto-overload feature), default argument values, and a brief look at call policies.\r\n\r\n4. Exposing classes\r\n\r\n    Here we\u2019ll look at how to expose C++ classes to Python. Topics will include the basic `class_<T>` template, member functions, data members, properties, inheritance, and virtual functions.\r\n\r\n5. `boost::python::object`\r\n\r\n    The `boost::python::object` class is Boost.Python\u2019s primary interface to Python\u2019s `PyObject` structure. Understanding how to work with this class is a key building-block for developing Python modules with Boost.Python. We\u2019ll explore its API and features, including areas like attribute access, reference counting, and converting between Python and C++ objects.\r\n\r\n6. Derived object types\r\n\r\n    Boost.Python provides a number of `boost::python::object` subclasses for important Python classes like `list`, `dict`, and `tuple`. In this section we\u2019ll look at these subclasses and how to use them in Boost.Python modules.\r\n\r\n7. Enums\r\n\r\n    Boost.Python provides `enum_<T>` for exposing C++ enums to Python. Python doesn\u2019t have a notion of enums *per se*, but in this section we\u2019ll explore how this template makes it straightforward to use C++ enums in Python in a simple and intuitive way.\r\n\r\n8. Type conversion\r\n\r\n    In this section we\u2019ll look at Boost.Python\u2019s support for doing automatic type-conversion across the Python/C++ boundary. We\u2019ll see how you can register type-converters with Boost.Python which will be invoked whenever Boost.Python needs to convert a Python object to a C++ object or vice versa.\r\n\r\nThis is a fairly ambitious set of topics, and it\u2019s possible that we won\u2019t be able to cover them all. The topics are roughly in most-often-used to least-often-used order, however, so students will be sure to be exposed to the most important and relevant elements of the course.\r\n\r\nLikewise, the four-hour format of the course means that we won\u2019t be able to go into great depth on many topics. The main goal of the course, then, is to give students enough orientation and hands-on experience with Boost.Python that they can continue to learn on their own. Inter-language integration - especially between languages as dissimilar as C++ and Python - can be quite complex, but this tutorial will give students the grounding they need to successfully apply Boost.Python to their problems.  \r\n", "quality_notes": "", "copyright_text": "http://www.youtube.com/t/terms", "embed": "<object width=\"640\" height=\"390\"><param name=\"movie\" value=\"http://youtube.com/v/GgtlExpPM1c?version=3&amp;hl=en_US\"></param><param name=\"allowFullScreen\" value=\"true\"></param><param name=\"allowscriptaccess\" value=\"always\"></param><embed src=\"http://youtube.com/v/GgtlExpPM1c?version=3&amp;hl=en_US\" type=\"application/x-shockwave-flash\" width=\"640\" height=\"390\" allowscriptaccess=\"always\" allowfullscreen=\"true\"></embed></object>", "thumbnail_url": "http://i1.ytimg.com/vi/GgtlExpPM1c/hqdefault.jpg", "duration": null, "video_ogv_length": null, "video_ogv_url": null, "video_ogv_download_only": false, "video_mp4_length": null, "video_mp4_url": null, "video_mp4_download_only": false, "video_webm_length": null, "video_webm_url": null, "video_webm_download_only": false, "video_flv_length": null, "video_flv_url": null, "video_flv_download_only": false, "source_url": "http://www.youtube.com/watch?v=GgtlExpPM1c", "whiteboard": "", "recorded": "2014-07-09", "added": "2014-07-10T22:35:19.833", "updated": "2014-07-10T22:35:19.833"}, {"category": "SciPy 2014", "language": "English", "slug": "interactive-parallel-computing-with-ipython-part", "speakers": ["Fernando P\u00e9rez", "Min RK"], "tags": ["ipython"], "related_urls": [], "id": 2738, "state": 1, "title": "Interactive Parallel Computing with IPython Part 1", "summary": "Learn about interactive parallel computing in IPython.parallel, with examples including parallel image processing, machine learning, and physical simulations. IPython provides an easy way to interact with your multicore laptop or compute cluster.", "description": "IPython provides tools for interactive exploration of code and data. IPython.parallel is the part of IPython that enables an interactive model for parallel execution, and aims to make distributing your work on a multicore computer, local clusters or cloud services such as AWS or MS Azure simple and straightforward. The tutorial will cover how to do interactive and asynchronous parallel computing with IPython, and how to get the most out of your IPython cluster. Some of IPython\u2019s novel interactive features will be demonstrated, such as automatically parallelizing code with magics in the IPython Notebook and interactive debugging of remote execution. Examples covered will include parallel image processing, machine learning, and physical simulations, with exercises to solve along the way.\r\n\r\n* Introduction to IPython.parallel\r\n   * Deploying IPython\r\n   * Using DirectViews and LoadBalancedViews\r\n   * The basic model for execution\r\n* Getting to know your IPython cluster:\r\n   * Working with remote namespaces\r\n   * AsyncResult: the API for asynchronous execution\r\n   * Interacting with incomplete results. Remember, it\u2019s about interactivity\r\n   * Interactive parallel plotting\r\n* More advanced topics:\r\n   * Using IPython.parallel with traditional (MPI) parallel programs\r\n   * Debugging parallel code\r\n   * Minimizing data movement\r\n   * Task dependencies\r\n   * Caveats and tuning tips for IPython.parallel", "quality_notes": "", "copyright_text": "http://www.youtube.com/t/terms", "embed": "<object width=\"640\" height=\"390\"><param name=\"movie\" value=\"http://youtube.com/v/y4hgalfhc1Y?version=3&amp;hl=en_US\"></param><param name=\"allowFullScreen\" value=\"true\"></param><param name=\"allowscriptaccess\" value=\"always\"></param><embed src=\"http://youtube.com/v/y4hgalfhc1Y?version=3&amp;hl=en_US\" type=\"application/x-shockwave-flash\" width=\"640\" height=\"390\" allowscriptaccess=\"always\" allowfullscreen=\"true\"></embed></object>", "thumbnail_url": "http://i1.ytimg.com/vi/y4hgalfhc1Y/hqdefault.jpg", "duration": null, "video_ogv_length": null, "video_ogv_url": "", "video_ogv_download_only": false, "video_mp4_length": null, "video_mp4_url": "", "video_mp4_download_only": false, "video_webm_length": null, "video_webm_url": "", "video_webm_download_only": false, "video_flv_length": null, "video_flv_url": "", "video_flv_download_only": false, "source_url": "http://www.youtube.com/watch?v=y4hgalfhc1Y", "whiteboard": "", "recorded": "2014-07-09", "added": "2014-07-10T22:35:12.896", "updated": "2014-10-26T16:28:46.501"}, {"category": "SciPy 2014", "language": "English", "slug": "interactive-parallel-computing-with-ipython-part-0", "speakers": ["Fernando P\u00e9rez", "Min RK"], "tags": ["ipython"], "related_urls": [], "id": 2740, "state": 1, "title": "Interactive Parallel Computing with IPython Part 2", "summary": "Learn about interactive parallel computing in IPython.parallel, with examples including parallel image processing, machine learning, and physical simulations. IPython provides an easy way to interact with your multicore laptop or compute cluster.", "description": "IPython provides tools for interactive exploration of code and data. IPython.parallel is the part of IPython that enables an interactive model for parallel execution, and aims to make distributing your work on a multicore computer, local clusters or cloud services such as AWS or MS Azure simple and straightforward. The tutorial will cover how to do interactive and asynchronous parallel computing with IPython, and how to get the most out of your IPython cluster. Some of IPython\u2019s novel interactive features will be demonstrated, such as automatically parallelizing code with magics in the IPython Notebook and interactive debugging of remote execution. Examples covered will include parallel image processing, machine learning, and physical simulations, with exercises to solve along the way.\r\n\r\n* Introduction to IPython.parallel\r\n   * Deploying IPython\r\n   * Using DirectViews and LoadBalancedViews\r\n   * The basic model for execution\r\n* Getting to know your IPython cluster:\r\n   * Working with remote namespaces\r\n   * AsyncResult: the API for asynchronous execution\r\n   * Interacting with incomplete results. Remember, it\u2019s about interactivity\r\n   * Interactive parallel plotting\r\n* More advanced topics:\r\n   * Using IPython.parallel with traditional (MPI) parallel programs\r\n   * Debugging parallel code\r\n   * Minimizing data movement\r\n   * Task dependencies\r\n   * Caveats and tuning tips for IPython.parallel", "quality_notes": "", "copyright_text": "http://www.youtube.com/t/terms", "embed": "<object width=\"640\" height=\"390\"><param name=\"movie\" value=\"http://youtube.com/v/-9ijnHPCYhY?version=3&amp;hl=en_US\"></param><param name=\"allowFullScreen\" value=\"true\"></param><param name=\"allowscriptaccess\" value=\"always\"></param><embed src=\"http://youtube.com/v/-9ijnHPCYhY?version=3&amp;hl=en_US\" type=\"application/x-shockwave-flash\" width=\"640\" height=\"390\" allowscriptaccess=\"always\" allowfullscreen=\"true\"></embed></object>", "thumbnail_url": "http://i1.ytimg.com/vi/-9ijnHPCYhY/hqdefault.jpg", "duration": null, "video_ogv_length": null, "video_ogv_url": "", "video_ogv_download_only": false, "video_mp4_length": null, "video_mp4_url": "", "video_mp4_download_only": false, "video_webm_length": null, "video_webm_url": "", "video_webm_download_only": false, "video_flv_length": null, "video_flv_url": "", "video_flv_download_only": false, "source_url": "http://www.youtube.com/watch?v=-9ijnHPCYhY", "whiteboard": "", "recorded": "2014-07-09", "added": "2014-07-10T22:35:13.767", "updated": "2014-10-26T16:29:05.691"}, {"category": "SciPy 2014", "language": "English", "slug": "interactive-parallel-computing-with-ipython-part-1", "speakers": ["Fernando P\u00e9rez", "Min RK"], "tags": ["ipython"], "related_urls": [], "id": 2741, "state": 1, "title": "Interactive Parallel Computing with IPython Part 3", "summary": "Learn about interactive parallel computing in IPython.parallel, with examples including parallel image processing, machine learning, and physical simulations. IPython provides an easy way to interact with your multicore laptop or compute cluster.", "description": "IPython provides tools for interactive exploration of code and data. IPython.parallel is the part of IPython that enables an interactive model for parallel execution, and aims to make distributing your work on a multicore computer, local clusters or cloud services such as AWS or MS Azure simple and straightforward. The tutorial will cover how to do interactive and asynchronous parallel computing with IPython, and how to get the most out of your IPython cluster. Some of IPython\u2019s novel interactive features will be demonstrated, such as automatically parallelizing code with magics in the IPython Notebook and interactive debugging of remote execution. Examples covered will include parallel image processing, machine learning, and physical simulations, with exercises to solve along the way.\r\n\r\n* Introduction to IPython.parallel\r\n   * Deploying IPython\r\n   * Using DirectViews and LoadBalancedViews\r\n   * The basic model for execution\r\n* Getting to know your IPython cluster:\r\n   * Working with remote namespaces\r\n   * AsyncResult: the API for asynchronous execution\r\n   * Interacting with incomplete results. Remember, it\u2019s about interactivity\r\n   * Interactive parallel plotting\r\n* More advanced topics:\r\n   * Using IPython.parallel with traditional (MPI) parallel programs\r\n   * Debugging parallel code\r\n   * Minimizing data movement\r\n   * Task dependencies\r\n   * Caveats and tuning tips for IPython.parallel", "quality_notes": "", "copyright_text": "http://www.youtube.com/t/terms", "embed": "<object width=\"640\" height=\"390\"><param name=\"movie\" value=\"http://youtube.com/v/U5mhpKkIx2Y?version=3&amp;hl=en_US\"></param><param name=\"allowFullScreen\" value=\"true\"></param><param name=\"allowscriptaccess\" value=\"always\"></param><embed src=\"http://youtube.com/v/U5mhpKkIx2Y?version=3&amp;hl=en_US\" type=\"application/x-shockwave-flash\" width=\"640\" height=\"390\" allowscriptaccess=\"always\" allowfullscreen=\"true\"></embed></object>", "thumbnail_url": "http://i1.ytimg.com/vi/U5mhpKkIx2Y/hqdefault.jpg", "duration": null, "video_ogv_length": null, "video_ogv_url": "", "video_ogv_download_only": false, "video_mp4_length": null, "video_mp4_url": "", "video_mp4_download_only": false, "video_webm_length": null, "video_webm_url": "", "video_webm_download_only": false, "video_flv_length": null, "video_flv_url": "", "video_flv_download_only": false, "source_url": "http://www.youtube.com/watch?v=U5mhpKkIx2Y", "whiteboard": "", "recorded": "2014-07-09", "added": "2014-07-10T22:35:14.157", "updated": "2014-10-26T16:29:21.211"}, {"category": "SciPy 2014", "language": "English", "slug": "intergrating-pylearn2-and-hyperopt-taking-deep-l", "speakers": ["David Warde-Farley"], "tags": ["machine learning"], "related_urls": [], "id": 2731, "state": 1, "title": "Intergrating Pylearn2 and Hyperopt: Taking Deep Learning Further with Hyperparamter Optimization", "summary": "This talk/poster will outline and present recent work in integrating Hyperopt, a package for the optimization of the hyperparameters of machine learning algorithms, with Pylearn2, a machine learning research and prototyping framework focused on \"deep learning\" algorithms, the technical challenges we faced and how we addressed them.", "description": "Deep learning algorithms have recently garnered much attention for their successes in solving very difficult industrial machine perception problems. However, for many practical purposes, these algorithms are unwieldy due to the rapid proliferation of \"hyperparameters\" in their specification -- architectural and optimization constants which ordinarily must be specified a priori by the practitioner. There is a growing interest within the machine learning community, and acutely so amongst deep learning researchers, in intelligently automating the selection of hyperparameters for machine learning algorithms by through the use of sequential model-based optimization techniques. [Hyperopt][http://hyperopt.github.io/hyperopt/] is software package designed for this purpose, architected as a general framework for hyperparameter optimization algorithms with support for complicated, awkward hyperparameter spaces that, e.g., involve many hyperparameters that are only meaningful in the context of certain values of other hyperparameters.\r\n\r\n[Pylearn2][http://deeplearning.net/software/pylearn2] is a framework for machine learning developed by the LISA laboratory at Universit\u00e9 de Montr\u00e9al; it is a research and prototyping library aimed primarily at machine learning researchers, with a focus on \"deep learning\" algorithms. Despite being far from a stable release, it has had considerable impact and developed a very active user community outside of the laboratory that birthed it.\r\n\r\nThis talk will deecribe recent efforts in building a flexible, user-friendly bridge between Pylearn2 and Hyperopt for the purpose of optimizing the hyperparameters of deep learning algorithms. Briefly, it will outline the relevant problem domain and the two packages, the technical challenges we've met in adapting the two for use with one another and our solutions to them, in particular the development of a novel common deferred evaluation/call-graph description language based on `functools.partial`, which we hope to make available in the near future as a standalone package.", "quality_notes": "", "copyright_text": "http://www.youtube.com/t/terms", "embed": "<object width=\"640\" height=\"390\"><param name=\"movie\" value=\"http://youtube.com/v/t50CGzbtcrY?version=3&amp;hl=en_US\"></param><param name=\"allowFullScreen\" value=\"true\"></param><param name=\"allowscriptaccess\" value=\"always\"></param><embed src=\"http://youtube.com/v/t50CGzbtcrY?version=3&amp;hl=en_US\" type=\"application/x-shockwave-flash\" width=\"640\" height=\"390\" allowscriptaccess=\"always\" allowfullscreen=\"true\"></embed></object>", "thumbnail_url": "http://i1.ytimg.com/vi/t50CGzbtcrY/hqdefault.jpg", "duration": null, "video_ogv_length": null, "video_ogv_url": "", "video_ogv_download_only": false, "video_mp4_length": null, "video_mp4_url": "", "video_mp4_download_only": false, "video_webm_length": null, "video_webm_url": "", "video_webm_download_only": false, "video_flv_length": null, "video_flv_url": "", "video_flv_download_only": false, "source_url": "http://www.youtube.com/watch?v=t50CGzbtcrY", "whiteboard": "", "recorded": "2014-07-09", "added": "2014-07-09T19:24:56.143", "updated": "2014-07-09T19:28:30.270"}, {"category": "SciPy 2014", "language": "English", "slug": "introduction-to-julia-part-1", "speakers": ["David P. Sanders"], "tags": ["Tech"], "related_urls": [], "id": 2754, "state": 1, "title": "Introduction to Julia - Part 1", "summary": "An introduction to the new Julia language from scratch, emphasising similarities and differences with scientific Python.", "description": "Julia is a new, up-and-coming language that has many similarities to Python, but some differences.\r\nOne of its main advantages is the speed gain obtained by automatically compiling all code (in a somewhat similar way to `PyPy`, `Cython`, `numba`, etc.), despite having an interactive interface very similar to that of Python. \r\n\r\nThis will be a tutorial on the basic features of Julia from scratch, given by a user (rather than a developer) of the language, emphasising those features which are similar to Python (and hence do not require much explanation) and those features which are rather different. \r\n\r\nThe idea of the tutorial is to give an idea of why there is suddenly such a buzz around Julia and why it can be useful for certain projects.\r\n\r\nThis tutorial is aimed at people who are already familiar with the basic scientific Python packages; it is not aimed at beginners in scientific programming.", "quality_notes": "", "copyright_text": "http://www.youtube.com/t/terms", "embed": "<object width=\"640\" height=\"390\"><param name=\"movie\" value=\"http://youtube.com/v/vWkgEddb4-A?version=3&amp;hl=en_US\"></param><param name=\"allowFullScreen\" value=\"true\"></param><param name=\"allowscriptaccess\" value=\"always\"></param><embed src=\"http://youtube.com/v/vWkgEddb4-A?version=3&amp;hl=en_US\" type=\"application/x-shockwave-flash\" width=\"640\" height=\"390\" allowscriptaccess=\"always\" allowfullscreen=\"true\"></embed></object>", "thumbnail_url": "http://i1.ytimg.com/vi/vWkgEddb4-A/hqdefault.jpg", "duration": null, "video_ogv_length": null, "video_ogv_url": null, "video_ogv_download_only": false, "video_mp4_length": null, "video_mp4_url": null, "video_mp4_download_only": false, "video_webm_length": null, "video_webm_url": null, "video_webm_download_only": false, "video_flv_length": null, "video_flv_url": null, "video_flv_download_only": false, "source_url": "http://www.youtube.com/watch?v=vWkgEddb4-A", "whiteboard": "", "recorded": "2014-07-09", "added": "2014-07-10T22:35:22.269", "updated": "2014-07-10T22:35:22.269"}, {"category": "SciPy 2014", "language": "English", "slug": "introduction-to-julia-part-2", "speakers": ["David P. Sanders"], "tags": ["julia"], "related_urls": [], "id": 2753, "state": 1, "title": "Introduction to Julia - Part 2", "summary": "An introduction to the new Julia language from scratch, emphasising similarities and differences with scientific Python.", "description": "Julia is a new, up-and-coming language that has many similarities to Python, but some differences.\r\nOne of its main advantages is the speed gain obtained by automatically compiling all code (in a somewhat similar way to `PyPy`, `Cython`, `numba`, etc.), despite having an interactive interface very similar to that of Python. \r\n\r\nThis will be a tutorial on the basic features of Julia from scratch, given by a user (rather than a developer) of the language, emphasising those features which are similar to Python (and hence do not require much explanation) and those features which are rather different. \r\n\r\nThe idea of the tutorial is to give an idea of why there is suddenly such a buzz around Julia and why it can be useful for certain projects.\r\n\r\nThis tutorial is aimed at people who are already familiar with the basic scientific Python packages; it is not aimed at beginners in scientific programming.", "quality_notes": "", "copyright_text": "http://www.youtube.com/t/terms", "embed": "<object width=\"640\" height=\"390\"><param name=\"movie\" value=\"http://youtube.com/v/I3JH5Bg46yU?version=3&amp;hl=en_US\"></param><param name=\"allowFullScreen\" value=\"true\"></param><param name=\"allowscriptaccess\" value=\"always\"></param><embed src=\"http://youtube.com/v/I3JH5Bg46yU?version=3&amp;hl=en_US\" type=\"application/x-shockwave-flash\" width=\"640\" height=\"390\" allowscriptaccess=\"always\" allowfullscreen=\"true\"></embed></object>", "thumbnail_url": "http://i1.ytimg.com/vi/I3JH5Bg46yU/hqdefault.jpg", "duration": null, "video_ogv_length": null, "video_ogv_url": null, "video_ogv_download_only": false, "video_mp4_length": null, "video_mp4_url": null, "video_mp4_download_only": false, "video_webm_length": null, "video_webm_url": null, "video_webm_download_only": false, "video_flv_length": null, "video_flv_url": null, "video_flv_download_only": false, "source_url": "http://www.youtube.com/watch?v=I3JH5Bg46yU", "whiteboard": "", "recorded": "2014-07-09", "added": "2014-07-10T22:35:21.882", "updated": "2014-07-10T22:35:21.882"}, {"category": "SciPy 2014", "language": "English", "slug": "keynote-lorena-barba", "speakers": ["Lorena Barba"], "tags": [], "related_urls": [{"url": "http://figshare.com/articles/If_there_s_Computational_Thinking_there_s_Computational_Learning/1096344", "description": "Slides"}], "id": 2719, "state": 1, "title": "Keynote: Computational Thinking is Computational Learning", "summary": "", "description": "", "quality_notes": "", "copyright_text": "http://www.youtube.com/t/terms", "embed": "<object width=\"640\" height=\"390\"><param name=\"movie\" value=\"http://youtube.com/v/TWxwKDT88GU?version=3&amp;hl=en_US\"></param><param name=\"allowFullScreen\" value=\"true\"></param><param name=\"allowscriptaccess\" value=\"always\"></param><embed src=\"http://youtube.com/v/TWxwKDT88GU?version=3&amp;hl=en_US\" type=\"application/x-shockwave-flash\" width=\"640\" height=\"390\" allowscriptaccess=\"always\" allowfullscreen=\"true\"></embed></object>", "thumbnail_url": "http://i1.ytimg.com/vi/TWxwKDT88GU/hqdefault.jpg", "duration": null, "video_ogv_length": null, "video_ogv_url": "", "video_ogv_download_only": false, "video_mp4_length": null, "video_mp4_url": "", "video_mp4_download_only": false, "video_webm_length": null, "video_webm_url": "", "video_webm_download_only": false, "video_flv_length": null, "video_flv_url": "", "video_flv_download_only": false, "source_url": "http://www.youtube.com/watch?v=TWxwKDT88GU", "whiteboard": "", "recorded": "2014-07-09", "added": "2014-07-09T19:24:51.232", "updated": "2014-07-10T22:42:06.642"}, {"category": "SciPy 2014", "language": "English", "slug": "lightning-talks-tuesday-july-8-2014", "speakers": [], "tags": [], "related_urls": [], "id": 2716, "state": 1, "title": "Lightning Talks Tuesday July 8 2014", "summary": "", "description": "", "quality_notes": "", "copyright_text": "http://www.youtube.com/t/terms", "embed": "<object width=\"640\" height=\"390\"><param name=\"movie\" value=\"http://youtube.com/v/JDrhn0-r9Eg?version=3&amp;hl=en_US\"></param><param name=\"allowFullScreen\" value=\"true\"></param><param name=\"allowscriptaccess\" value=\"always\"></param><embed src=\"http://youtube.com/v/JDrhn0-r9Eg?version=3&amp;hl=en_US\" type=\"application/x-shockwave-flash\" width=\"640\" height=\"390\" allowscriptaccess=\"always\" allowfullscreen=\"true\"></embed></object>", "thumbnail_url": "http://i1.ytimg.com/vi/JDrhn0-r9Eg/hqdefault.jpg", "duration": null, "video_ogv_length": null, "video_ogv_url": null, "video_ogv_download_only": false, "video_mp4_length": null, "video_mp4_url": null, "video_mp4_download_only": false, "video_webm_length": null, "video_webm_url": null, "video_webm_download_only": false, "video_flv_length": null, "video_flv_url": null, "video_flv_download_only": false, "source_url": "http://www.youtube.com/watch?v=JDrhn0-r9Eg", "whiteboard": "", "recorded": "2014-07-09", "added": "2014-07-09T19:24:50.053", "updated": "2014-07-09T19:24:50.053"}, {"category": "SciPy 2014", "language": "English", "slug": "multibody-dynamics-and-control-with-python-part-1", "speakers": ["Jason K. Moore"], "tags": ["robots", "simulation", "sympy"], "related_urls": [], "id": 2747, "state": 1, "title": "Multibody Dynamics and Control with Python part 1", "summary": "In this tutorial, attendees will learn how to derive, simulate, and visualize\r\nthe motion of a multibody dynamic system with Python tools. These methods and\r\ntechniques play an important role in the design and understanding of robots,\r\nvehicles, spacecraft, manufacturing machines, human motion, etc. Attendees will\r\ndevelop code to simulate the motion of a human or humanoid robot.", "description": "In this tutorial, attendees will learn how to derive, simulate, and visualize\r\nthe motion of a multibody dynamic system with Python tools. The tutorial will\r\ndemonstrate an advanced symbolic and numeric pipeline for a typical multibody\r\nsimulation problem. These methods and techniques play an important role in the\r\ndesign and understanding of robots, vehicles, spacecraft, manufacturing\r\nmachines, human motion, etc. At the end, the attendees will have developed code\r\nto simulate the uncontrolled and controlled motion of a human or humanoid\r\nrobot.\r\n\r\nWe will highlight the derivation of realistic models of motion with the SymPy\r\nMechanics package. We will walk through the derivation of the equations of\r\nmotion of a multibody system (i.e. the model or the plant), simulating and\r\nvisualizing the free motion of the system, and finally we will addfeedback\r\ncontrollers to control the plants that we derive.\r\n\r\nIt is best if the attendees have some background with calculus-based college\r\nlevel physics. They should also be familiar with the SciPy Stack, in particular\r\nIPython, SymPy, NumPy, and SciPy. Our goal is that attendees will come away\r\nwith the ability to model basic multibody systems, simulate and visualize the\r\nmotion, and apply feedback controllers all in a Python framework.\r\n\r\nThe tutorial materials including an outline can be viewed here:\r\n\r\n[https://github.com/pydy/pydy-tutorial-pycon-2014](https://github.com/pydy/pydy-tutorial-pycon-2014)\r\n", "quality_notes": "", "copyright_text": "http://www.youtube.com/t/terms", "embed": "<object width=\"640\" height=\"390\"><param name=\"movie\" value=\"http://youtube.com/v/lWbeuDwYVto?version=3&amp;hl=en_US\"></param><param name=\"allowFullScreen\" value=\"true\"></param><param name=\"allowscriptaccess\" value=\"always\"></param><embed src=\"http://youtube.com/v/lWbeuDwYVto?version=3&amp;hl=en_US\" type=\"application/x-shockwave-flash\" width=\"640\" height=\"390\" allowscriptaccess=\"always\" allowfullscreen=\"true\"></embed></object>", "thumbnail_url": "http://i1.ytimg.com/vi/lWbeuDwYVto/hqdefault.jpg", "duration": null, "video_ogv_length": null, "video_ogv_url": null, "video_ogv_download_only": false, "video_mp4_length": null, "video_mp4_url": null, "video_mp4_download_only": false, "video_webm_length": null, "video_webm_url": null, "video_webm_download_only": false, "video_flv_length": null, "video_flv_url": null, "video_flv_download_only": false, "source_url": "http://www.youtube.com/watch?v=lWbeuDwYVto", "whiteboard": "", "recorded": "2014-07-09", "added": "2014-07-10T22:35:16.816", "updated": "2014-07-10T22:35:16.816"}, {"category": "SciPy 2014", "language": "English", "slug": "multibody-dynamics-and-control-with-python-part-2", "speakers": ["Jason K. Moore"], "tags": ["robots", "simulation", "sympy"], "related_urls": [], "id": 2745, "state": 1, "title": "Multibody Dynamics and Control with Python part 2", "summary": "In this tutorial, attendees will learn how to derive, simulate, and visualize\r\nthe motion of a multibody dynamic system with Python tools. These methods and\r\ntechniques play an important role in the design and understanding of robots,\r\nvehicles, spacecraft, manufacturing machines, human motion, etc. Attendees will\r\ndevelop code to simulate the motion of a human or humanoid robot.", "description": "In this tutorial, attendees will learn how to derive, simulate, and visualize\r\nthe motion of a multibody dynamic system with Python tools. The tutorial will\r\ndemonstrate an advanced symbolic and numeric pipeline for a typical multibody\r\nsimulation problem. These methods and techniques play an important role in the\r\ndesign and understanding of robots, vehicles, spacecraft, manufacturing\r\nmachines, human motion, etc. At the end, the attendees will have developed code\r\nto simulate the uncontrolled and controlled motion of a human or humanoid\r\nrobot.\r\n\r\nWe will highlight the derivation of realistic models of motion with the SymPy\r\nMechanics package. We will walk through the derivation of the equations of\r\nmotion of a multibody system (i.e. the model or the plant), simulating and\r\nvisualizing the free motion of the system, and finally we will addfeedback\r\ncontrollers to control the plants that we derive.\r\n\r\nIt is best if the attendees have some background with calculus-based college\r\nlevel physics. They should also be familiar with the SciPy Stack, in particular\r\nIPython, SymPy, NumPy, and SciPy. Our goal is that attendees will come away\r\nwith the ability to model basic multibody systems, simulate and visualize the\r\nmotion, and apply feedback controllers all in a Python framework.\r\n\r\nThe tutorial materials including an outline can be viewed here:\r\n\r\n[https://github.com/pydy/pydy-tutorial-pycon-2014](https://github.com/pydy/pydy-tutorial-pycon-2014)\r\n", "quality_notes": "", "copyright_text": "http://www.youtube.com/t/terms", "embed": "<object width=\"640\" height=\"390\"><param name=\"movie\" value=\"http://youtube.com/v/1-KqRvNX0po?version=3&amp;hl=en_US\"></param><param name=\"allowFullScreen\" value=\"true\"></param><param name=\"allowscriptaccess\" value=\"always\"></param><embed src=\"http://youtube.com/v/1-KqRvNX0po?version=3&amp;hl=en_US\" type=\"application/x-shockwave-flash\" width=\"640\" height=\"390\" allowscriptaccess=\"always\" allowfullscreen=\"true\"></embed></object>", "thumbnail_url": "http://i1.ytimg.com/vi/1-KqRvNX0po/hqdefault.jpg", "duration": null, "video_ogv_length": null, "video_ogv_url": null, "video_ogv_download_only": false, "video_mp4_length": null, "video_mp4_url": null, "video_mp4_download_only": false, "video_webm_length": null, "video_webm_url": null, "video_webm_download_only": false, "video_flv_length": null, "video_flv_url": null, "video_flv_download_only": false, "source_url": "http://www.youtube.com/watch?v=1-KqRvNX0po", "whiteboard": "", "recorded": "2014-07-09", "added": "2014-07-10T22:35:15.964", "updated": "2014-07-10T22:35:15.964"}, {"category": "SciPy 2014", "language": "English", "slug": "object-oriented-programming-with-numpy-using-cpyt", "speakers": ["Dorota Jarecka"], "tags": ["pypy"], "related_urls": [], "id": 2733, "state": 1, "title": "Object oriented Programming with NumPy using CPython & PyPy", "summary": "In the paper we compare object-oriented implementations of an advection algorithm written in Python, C++ and modern FORTRAN. The main angles of comparison are code brevity and syntax clarity (and hence maintainability and auditability) as well as performance. A notable performance gain when switching from CPython to PyPy will be exemplified, and the reasons for it will be briefly explained. ", "description": "In the paper we compare object-oriented implementations of an advection algorithm written in Python, C++ and modern FORTRAN. The MPDATA advection algorithm (Multidimensional Positive-Definite Advective Transport Algorithm) used as a core of weather, ocean and climate modelling systems serves as an example.\r\n\r\nIn the context of scientific programming, employment of object-oriented programming (OOP) techniques may help to improve code readability, and hence its auditability and maintainability. OOP offers, in particular, the possibility to reproduce in the program code the mathematical \"blackboard abstractions\" used in the literature. We compare how the choice of a particular language influences syntax clarity, code length and the performance: CPU time and memory usage.\r\n\r\nThe Python implementation of MPDATA is based on NumPy. Its performance is compared with C++/Blitz++ and FORTRAN implementations. A notable performance gain when switching from the standard CPython to PyPy will be exemplified, and the reasons for it will be briefly explained. Discussion of other selected solutions for improving the NumPy\u2019s relatively poor performance will be also presented.\r\n\r\nThis talk will describe and extend on the key findings presented in http://arxiv.org/abs/1301.1334.", "quality_notes": "", "copyright_text": "http://www.youtube.com/t/terms", "embed": "<object width=\"640\" height=\"390\"><param name=\"movie\" value=\"http://youtube.com/v/i7rO2qPiesc?version=3&amp;hl=en_US\"></param><param name=\"allowFullScreen\" value=\"true\"></param><param name=\"allowscriptaccess\" value=\"always\"></param><embed src=\"http://youtube.com/v/i7rO2qPiesc?version=3&amp;hl=en_US\" type=\"application/x-shockwave-flash\" width=\"640\" height=\"390\" allowscriptaccess=\"always\" allowfullscreen=\"true\"></embed></object>", "thumbnail_url": "http://i1.ytimg.com/vi/i7rO2qPiesc/hqdefault.jpg", "duration": null, "video_ogv_length": null, "video_ogv_url": null, "video_ogv_download_only": false, "video_mp4_length": null, "video_mp4_url": null, "video_mp4_download_only": false, "video_webm_length": null, "video_webm_url": null, "video_webm_download_only": false, "video_flv_length": null, "video_flv_url": null, "video_flv_download_only": false, "source_url": "http://www.youtube.com/watch?v=i7rO2qPiesc", "whiteboard": "", "recorded": "2014-07-09", "added": "2014-07-10T22:35:10.550", "updated": "2014-07-10T22:35:10.550"}]}